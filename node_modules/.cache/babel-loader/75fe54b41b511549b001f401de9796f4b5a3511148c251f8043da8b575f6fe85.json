{"ast":null,"code":"import _slicedToArray from \"/Users/macbook/Documents/Java Script/JS_Lessons/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/Users/macbook/Documents/Java Script/JS_Lessons/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/macbook/Documents/Java Script/JS_Lessons/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"defaultTransition\"];\nimport { resolveElements } from '../../render/dom/utils/resolve-element.mjs';\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\nimport { fillOffset } from '../../utils/offsets/fill.mjs';\nimport { progress } from '../../utils/progress.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\nimport { calcNextTime } from './utils/calc-time.mjs';\nimport { addKeyframes } from './utils/edit.mjs';\nimport { compareByTime } from './utils/sort.mjs';\nfunction createAnimationsFromSequence(sequence) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$defaultTransitio = _ref.defaultTransition,\n    defaultTransition = _ref$defaultTransitio === void 0 ? {} : _ref$defaultTransitio,\n    sequenceTransition = _objectWithoutProperties(_ref, _excluded);\n  var scope = arguments.length > 2 ? arguments[2] : undefined;\n  var animationDefinitions = new Map();\n  var sequences = new Map();\n  var elementCache = {};\n  var timeLabels = new Map();\n  var prevTime = 0;\n  var currentTime = 0;\n  var totalDuration = 0;\n  /**\n   * Build the timeline by mapping over the sequence array and converting\n   * the definitions into keyframes and offsets with absolute time values.\n   * These will later get converted into relative offsets in a second pass.\n   */\n  var _loop = function _loop() {\n    var segment = sequence[i];\n    /**\n     * If this is a timeline label, mark it and skip the rest of this iteration.\n     */\n    if (typeof segment === \"string\") {\n      timeLabels.set(segment, currentTime);\n      return \"continue\";\n    } else if (!Array.isArray(segment)) {\n      timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n      return \"continue\";\n    }\n    var _segment = _slicedToArray(segment, 3),\n      subject = _segment[0],\n      keyframes = _segment[1],\n      _segment$ = _segment[2],\n      transition = _segment$ === void 0 ? {} : _segment$;\n    /**\n     * If a relative or absolute time value has been specified we need to resolve\n     * it in relation to the currentTime.\n     */\n    if (transition.at !== undefined) {\n      currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n    }\n    /**\n     * Keep track of the maximum duration in this definition. This will be\n     * applied to currentTime once the definition has been parsed.\n     */\n    var maxDuration = 0;\n    var resolveValueSequence = function resolveValueSequence(valueKeyframes, valueTransition, valueSequence) {\n      var elementIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var numElements = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var valueKeyframesAsList = keyframesAsList(valueKeyframes);\n      var _valueTransition$dura = valueTransition.duration,\n        duration = _valueTransition$dura === void 0 ? defaultTransition.duration || 0.3 : _valueTransition$dura,\n        _valueTransition$ease = valueTransition.ease,\n        ease = _valueTransition$ease === void 0 ? defaultTransition.ease || \"easeOut\" : _valueTransition$ease;\n      var delay = typeof valueTransition.delay === \"function\" ? valueTransition.delay(elementIndex, numElements) : valueTransition.delay || 0;\n      var startTime = currentTime + delay;\n      var targetTime = startTime + duration;\n      var _valueTransition$time = valueTransition.times,\n        times = _valueTransition$time === void 0 ? defaultOffset(valueKeyframesAsList) : _valueTransition$time;\n      /**\n       * If there's only one time offset of 0, fill in a second with length 1\n       */\n      if (times.length === 1 && times[0] === 0) {\n        times[1] = 1;\n      }\n      /**\n       * Fill out if offset if fewer offsets than keyframes\n       */\n      var remainder = times.length - valueKeyframesAsList.length;\n      remainder > 0 && fillOffset(times, remainder);\n      /**\n       * If only one value has been set, ie [1], push a null to the start of\n       * the keyframe array. This will let us mark a keyframe at this point\n       * that will later be hydrated with the previous value.\n       */\n      valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null);\n      /**\n       * Add keyframes, mapping offsets to absolute time.\n       */\n      addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n      maxDuration = Math.max(delay + duration, maxDuration);\n      totalDuration = Math.max(targetTime, totalDuration);\n    };\n    if (isMotionValue(subject)) {\n      var subjectSequence = getSubjectSequence(subject, sequences);\n      resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n    } else {\n      /**\n       * Find all the elements specified in the definition and parse value\n       * keyframes from their timeline definitions.\n       */\n      var elements = resolveElements(subject, scope, elementCache);\n      var numElements = elements.length;\n      /**\n       * For every element in this segment, process the defined values.\n       */\n      for (var elementIndex = 0; elementIndex < numElements; elementIndex++) {\n        /**\n         * Cast necessary, but we know these are of this type\n         */\n        keyframes = keyframes;\n        transition = transition;\n        var element = elements[elementIndex];\n        var _subjectSequence = getSubjectSequence(element, sequences);\n        for (var key in keyframes) {\n          resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, _subjectSequence), elementIndex, numElements);\n        }\n      }\n      prevTime = currentTime;\n      currentTime += maxDuration;\n    }\n  };\n  for (var i = 0; i < sequence.length; i++) {\n    var _ret = _loop();\n    if (_ret === \"continue\") continue;\n  }\n  /**\n   * For every element and value combination create a new animation.\n   */\n  sequences.forEach(function (valueSequences, element) {\n    for (var key in valueSequences) {\n      var valueSequence = valueSequences[key];\n      /**\n       * Arrange all the keyframes in ascending time order.\n       */\n      valueSequence.sort(compareByTime);\n      var keyframes = [];\n      var valueOffset = [];\n      var valueEasing = [];\n      /**\n       * For each keyframe, translate absolute times into\n       * relative offsets based on the total duration of the timeline.\n       */\n      for (var _i = 0; _i < valueSequence.length; _i++) {\n        var _valueSequence$_i = valueSequence[_i],\n          at = _valueSequence$_i.at,\n          value = _valueSequence$_i.value,\n          easing = _valueSequence$_i.easing;\n        keyframes.push(value);\n        valueOffset.push(progress(0, totalDuration, at));\n        valueEasing.push(easing || \"easeOut\");\n      }\n      /**\n       * If the first keyframe doesn't land on offset: 0\n       * provide one by duplicating the initial keyframe. This ensures\n       * it snaps to the first keyframe when the animation starts.\n       */\n      if (valueOffset[0] !== 0) {\n        valueOffset.unshift(0);\n        keyframes.unshift(keyframes[0]);\n        valueEasing.unshift(\"linear\");\n      }\n      /**\n       * If the last keyframe doesn't land on offset: 1\n       * provide one with a null wildcard value. This will ensure it\n       * stays static until the end of the animation.\n       */\n      if (valueOffset[valueOffset.length - 1] !== 1) {\n        valueOffset.push(1);\n        keyframes.push(null);\n      }\n      if (!animationDefinitions.has(element)) {\n        animationDefinitions.set(element, {\n          keyframes: {},\n          transition: {}\n        });\n      }\n      var definition = animationDefinitions.get(element);\n      definition.keyframes[key] = keyframes;\n      definition.transition[key] = _objectSpread(_objectSpread({}, defaultTransition), {}, {\n        duration: totalDuration,\n        ease: valueEasing,\n        times: valueOffset\n      }, sequenceTransition);\n    }\n  });\n  return animationDefinitions;\n}\nfunction getSubjectSequence(subject, sequences) {\n  !sequences.has(subject) && sequences.set(subject, {});\n  return sequences.get(subject);\n}\nfunction getValueSequence(name, sequences) {\n  if (!sequences[name]) sequences[name] = [];\n  return sequences[name];\n}\nfunction keyframesAsList(keyframes) {\n  return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\nfunction getValueTransition(transition, key) {\n  return transition[key] ? _objectSpread(_objectSpread({}, transition), transition[key]) : _objectSpread({}, transition);\n}\nexport { createAnimationsFromSequence, getValueTransition };","map":{"version":3,"names":["resolveElements","defaultOffset","fillOffset","progress","isMotionValue","calcNextTime","addKeyframes","compareByTime","createAnimationsFromSequence","sequence","defaultTransition","sequenceTransition","scope","animationDefinitions","Map","sequences","elementCache","timeLabels","prevTime","currentTime","totalDuration","segment","i","set","Array","isArray","name","at","subject","keyframes","transition","undefined","maxDuration","resolveValueSequence","valueKeyframes","valueTransition","valueSequence","elementIndex","numElements","valueKeyframesAsList","keyframesAsList","duration","ease","delay","startTime","targetTime","times","length","remainder","unshift","Math","max","subjectSequence","getSubjectSequence","getValueSequence","elements","element","key","getValueTransition","forEach","valueSequences","sort","valueOffset","valueEasing","value","easing","push","has","definition","get"],"sources":["/Users/macbook/Documents/Java Script/JS_Lessons/node_modules/framer-motion/dist/es/animation/sequence/create.mjs"],"sourcesContent":["import { resolveElements } from '../../render/dom/utils/resolve-element.mjs';\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\nimport { fillOffset } from '../../utils/offsets/fill.mjs';\nimport { progress } from '../../utils/progress.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\nimport { calcNextTime } from './utils/calc-time.mjs';\nimport { addKeyframes } from './utils/edit.mjs';\nimport { compareByTime } from './utils/sort.mjs';\n\nfunction createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope) {\n    const animationDefinitions = new Map();\n    const sequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the sequence array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < sequence.length; i++) {\n        const segment = sequence[i];\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (typeof segment === \"string\") {\n            timeLabels.set(segment, currentTime);\n            continue;\n        }\n        else if (!Array.isArray(segment)) {\n            timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n            continue;\n        }\n        let [subject, keyframes, transition = {}] = segment;\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (transition.at !== undefined) {\n            currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0;\n        const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numElements = 0) => {\n            const valueKeyframesAsList = keyframesAsList(valueKeyframes);\n            const { duration = defaultTransition.duration || 0.3, ease = defaultTransition.ease || \"easeOut\", } = valueTransition;\n            const delay = typeof valueTransition.delay === \"function\"\n                ? valueTransition.delay(elementIndex, numElements)\n                : valueTransition.delay || 0;\n            const startTime = currentTime + delay;\n            const targetTime = startTime + duration;\n            const { times = defaultOffset(valueKeyframesAsList) } = valueTransition;\n            /**\n             * If there's only one time offset of 0, fill in a second with length 1\n             */\n            if (times.length === 1 && times[0] === 0) {\n                times[1] = 1;\n            }\n            /**\n             * Fill out if offset if fewer offsets than keyframes\n             */\n            const remainder = times.length - valueKeyframesAsList.length;\n            remainder > 0 && fillOffset(times, remainder);\n            /**\n             * If only one value has been set, ie [1], push a null to the start of\n             * the keyframe array. This will let us mark a keyframe at this point\n             * that will later be hydrated with the previous value.\n             */\n            valueKeyframesAsList.length === 1 &&\n                valueKeyframesAsList.unshift(null);\n            /**\n             * Add keyframes, mapping offsets to absolute time.\n             */\n            addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n            maxDuration = Math.max(delay + duration, maxDuration);\n            totalDuration = Math.max(targetTime, totalDuration);\n        };\n        if (isMotionValue(subject)) {\n            const subjectSequence = getSubjectSequence(subject, sequences);\n            resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n        }\n        else {\n            /**\n             * Find all the elements specified in the definition and parse value\n             * keyframes from their timeline definitions.\n             */\n            const elements = resolveElements(subject, scope, elementCache);\n            const numElements = elements.length;\n            /**\n             * For every element in this segment, process the defined values.\n             */\n            for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\n                /**\n                 * Cast necessary, but we know these are of this type\n                 */\n                keyframes = keyframes;\n                transition = transition;\n                const element = elements[elementIndex];\n                const subjectSequence = getSubjectSequence(element, sequences);\n                for (const key in keyframes) {\n                    resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), elementIndex, numElements);\n                }\n            }\n            prevTime = currentTime;\n            currentTime += maxDuration;\n        }\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    sequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(progress(0, totalDuration, at));\n                valueEasing.push(easing || \"easeOut\");\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(\"linear\");\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            if (!animationDefinitions.has(element)) {\n                animationDefinitions.set(element, {\n                    keyframes: {},\n                    transition: {},\n                });\n            }\n            const definition = animationDefinitions.get(element);\n            definition.keyframes[key] = keyframes;\n            definition.transition[key] = {\n                ...defaultTransition,\n                duration: totalDuration,\n                ease: valueEasing,\n                times: valueOffset,\n                ...sequenceTransition,\n            };\n        }\n    });\n    return animationDefinitions;\n}\nfunction getSubjectSequence(subject, sequences) {\n    !sequences.has(subject) && sequences.set(subject, {});\n    return sequences.get(subject);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name])\n        sequences[name] = [];\n    return sequences[name];\n}\nfunction keyframesAsList(keyframes) {\n    return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\nfunction getValueTransition(transition, key) {\n    return transition[key]\n        ? { ...transition, ...transition[key] }\n        : { ...transition };\n}\n\nexport { createAnimationsFromSequence, getValueTransition };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}