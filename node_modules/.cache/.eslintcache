[{"/Users/macbook/Documents/Java Script/JS_Lessons/src/index.js":"1","/Users/macbook/Documents/Java Script/JS_Lessons/src/App.js":"2","/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/ListData.js":"3","/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/Navbar/Navbar.jsx":"4","/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/Lessons/M1L2.jsx":"5","/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/Lessons/GitHub.jsx":"6","/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/Lessons/M1L1.jsx":"7","/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/Header/Header.jsx":"8","/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/Lessons/Arrey.jsx":"9","/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/Lessons/Function.jsx":"10","/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/Lessons/Object.jsx":"11","/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/Lessons/SpreadRest.jsx":"12","/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/Lessons/CallBack.jsx":"13","/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/Lessons/ArrMethod.jsx":"14","/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/Lessons/This.jsx":"15"},{"size":302,"mtime":1675270546355,"results":"16","hashOfConfig":"17"},{"size":1796,"mtime":1680514471189,"results":"18","hashOfConfig":"17"},{"size":1938,"mtime":1675270546321,"results":"19","hashOfConfig":"17"},{"size":3036,"mtime":1680514507873,"results":"20","hashOfConfig":"17"},{"size":40065,"mtime":1679249061176,"results":"21","hashOfConfig":"17"},{"size":300,"mtime":1675270546320,"results":"22","hashOfConfig":"17"},{"size":86554,"mtime":1678659474882,"results":"23","hashOfConfig":"17"},{"size":260,"mtime":1675270546319,"results":"24","hashOfConfig":"17"},{"size":40826,"mtime":1678395397980,"results":"25","hashOfConfig":"17"},{"size":39245,"mtime":1679249742338,"results":"26","hashOfConfig":"17"},{"size":41566,"mtime":1679250339877,"results":"27","hashOfConfig":"17"},{"size":32982,"mtime":1678368944976,"results":"28","hashOfConfig":"17"},{"size":28930,"mtime":1679851348455,"results":"29","hashOfConfig":"17"},{"size":62837,"mtime":1679863793709,"results":"30","hashOfConfig":"17"},{"size":24327,"mtime":1680519686910,"results":"31","hashOfConfig":"17"},{"filePath":"32","messages":"33","suppressedMessages":"34","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35","usedDeprecatedRules":"36"},"1jvf9ve",{"filePath":"37","messages":"38","suppressedMessages":"39","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"40","messages":"41","suppressedMessages":"42","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"43","messages":"44","suppressedMessages":"45","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"46","messages":"47","suppressedMessages":"48","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"49"},{"filePath":"50","messages":"51","suppressedMessages":"52","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"36"},{"filePath":"54","messages":"55","suppressedMessages":"56","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"57"},{"filePath":"58","messages":"59","suppressedMessages":"60","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"61","messages":"62","suppressedMessages":"63","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"64","messages":"65","suppressedMessages":"66","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"67","messages":"68","suppressedMessages":"69","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"70","messages":"71","suppressedMessages":"72","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"73"},{"filePath":"74","messages":"75","suppressedMessages":"76","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"77"},{"filePath":"78","messages":"79","suppressedMessages":"80","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"81"},{"filePath":"82","messages":"83","suppressedMessages":"84","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/Users/macbook/Documents/Java Script/JS_Lessons/src/index.js",["85"],[],"import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport listData from './Components/ListData';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <App />\n\n  </React.StrictMode>\n);\n\n",[],"/Users/macbook/Documents/Java Script/JS_Lessons/src/App.js",["86","87","88","89","90"],[],"/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/ListData.js",[],[],"/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/Navbar/Navbar.jsx",["91","92","93"],[],"/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/Lessons/M1L2.jsx",["94","95","96","97","98"],[],"import React from \"react\";\nimport s from \"./Lessons.module.css\";\nimport sprite from \"../../img/icomoon/sprite.svg\";\nimport ifImg from \"../../img/if.png\";\nimport ifElse from \"../../img/if-else.png\";\nimport elseIf from \"../../img/else-if.png\";\n\nimport operatorTable1 from \"../../img/not-strict-equality.png\";\nimport operatorTable2 from \"../../img/strict-equality.png\";\nimport string from \"../../img/string-idx.png\";\nimport code1 from \"../../img/code1.png\";\nimport booleanOperators from \"../../img/boolean-operators.png\";\nimport Scrollspy from \"react-scrollspy\";\nimport switchImg from \"../../img/switch.png\";\nimport globalScope from \"../../img/GlobalScope.png\";\nimport WhileCicle from \"../../img/WhileCicle.png\";\nimport doWhile from \"../../img/doWhile.png\";\nimport { Prism as SyntaxHighlighter } from \"react-syntax-highlighter\";\nimport { materialDark } from \"react-syntax-highlighter/dist/esm/styles/prism\";\n\nconst M1L2 = () => {\n  const codeStyle = materialDark;\n\n  return (\n    <div className={s.lessonsBox}>\n      <div className={s.breadNav}>\n        <Scrollspy\n          items={[\"branching\", \"section-2\", \"section-3\"]}\n          currentClassName=\"is-current\"\n        >\n          <div className={s.breadNavList}>\n            <li>\n              <a href=\"#branching\">Розгалуження</a>\n            </li>\n            <li>\n              <a href=\"#ternary operator\">Тернарний оператор</a>\n            </li>\n            <li>\n              <a href=\"#switch\">Інструкція switch</a>\n            </li>\n            <li>\n              <a href=\"#fieldOfView\">Область видимості</a>\n            </li>\n\n            <li>\n              <a href=\"#Cycles\">Цикли</a>\n            </li>\n          </div>\n        </Scrollspy>\n      </div>\n      <div className={s.article}>\n        <h1 id=\"branching\">Розгалуження</h1>\n        <p>\n          Розгалуження використовуються для виконання різного коду залежно від\n          умови. Принцип роботи простий - результат умови наводиться до булю\n          <span className={s.Span}>true</span> або{\" \"}\n          <span className={s.Span}>false</span> після чого потік програми\n          направляється в ту чи іншу гілку.\n        </p>\n        <h4>\n          Інструкція{\" \"}\n          <strong>\n            <span className={s.Span}>if</span>\n          </strong>\n        </h4>\n        <div style={{ display: \"flex\", justifyContent: \"center\" }}>\n          <img src={ifImg} alt=\"\" />\n        </div>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n                 if (умова) {\n                // тіло if\n                }\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Вхідні дані, що наводяться до булю, називаються{\" \"}\n          <strong>умовою</strong> . Умову поміщають за оператором{\" \"}\n          <span className={s.Span}>if</span> у круглих дужках. Якщо умова\n          наводиться до <span className={s.Span}>true</span>, то виконується код\n          у фігурних дужках тіла <span className={s.Span}>if</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n                let cost = 0;\n                const subscription = \"pro\";\n\n                if (subscription === \"pro\") {\n                cost = 100;\n                }\n\n                console.log(cost); // 100\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Якщо умова наводиться до <span className={s.Span}>false</span>, код у\n          фігурних дужках буде пропущено.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            let cost = 0;\n            const subscription = \"free\";\n\n            if (subscription === \"pro\") {\n            cost = 100;\n            }\n\n            console.log(cost); // 0\n                `}\n        </SyntaxHighlighter>\n        <h4>\n          Інструкція{\" \"}\n          <strong>\n            <span className={s.Span}>if...else</span>\n          </strong>\n        </h4>\n        <div style={{ display: \"flex\", justifyContent: \"center\" }}>\n          <img src={ifElse} alt=\"\" />\n        </div>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            if (умова) {\n            // тіло if\n            } else {\n            // тіло else\n            }\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Розширює синтаксис <span className={s.Span}>if</span> тим, що якщо\n          умова наводиться до\n          <span className={s.Span}>false</span>, виконається код у фігурних\n          дужках після оператора\n          <span className={s.Span}>else</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            let cost;\n            const subscription = \"free\";\n\n            if (subscription === \"pro\") {\n            cost = 100;\n            } else {\n            cost = 0;\n            }\n\n            console.log(cost); // 0\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Якщо умова наводиться до <span className={s.Span}>true</span>, тіло\n          блоку\n          <span className={s.Span}>else</span> ігнорується.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            let cost;\n            const subscription = \"pro\";\n\n            if (subscription === \"pro\") {\n            cost = 100;\n            } else {\n            cost = 0;\n            }\n\n            console.log(cost); // 100\n                `}\n        </SyntaxHighlighter>\n        <h3>\n          Інструкція{\" \"}\n          <strong>\n            <span className={s.Span}>else...if</span>\n          </strong>\n        </h3>\n        <div style={{ display: \"flex\", justifyContent: \"center\" }}>\n          <img src={elseIf} alt=\"\" />\n        </div>\n        <p>\n          Конструкція <span className={s.Span}>if...else</span> може перевірити\n          та зреагувати на виконання або невиконання лише однієї умови.\n        </p>\n        <p>\n          Блок <span className={s.Span}>else...if</span> дозволяє додати{\" \"}\n          <span className={s.Span}>else</span> ще один оператор{\" \"}\n          <span className={s.Span}>if</span> з умовою. В кінці ланцюжка може\n          бути класичний блок <span className={s.Span}>else</span>, який\n          виконається тільки у випадку, коли жодна з умов не приведеться до{\" \"}\n          <span className={s.Span}>true</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            let cost;\n            const subscription = \"mium\";\n\n            if (subscription === \"free\") {\n            cost = 0;\n            } else if (subscription === \"pro\") {\n            cost = 100;\n            } else if (subscription === \"mium\") {\n            cost = 500;\n            } else {\n            console.log(\"Invalid subscription type\");\n            }\n\n            console.log(cost); // 500\n                `}\n        </SyntaxHighlighter>\n        <p>\n          При першому ж <span className={s.Span}>true</span> перевірки\n          припиняться і виконається лише один сценарій, що відповідає цьому{\" \"}\n          <span className={s.Span}>true</span>. Тому такий запис слід читати як:\n          шукаю перший збіг умови, ігнорую все інше.\n        </p>\n        <h1 id=\"ternary operator\">Тернарний оператор</h1>\n        <p>\n          Тернарний оператор використовується як синтаксично коротка заміна\n          інструкції <span className={s.Span}>if...else</span>, коли однієї й\n          тієї ж змінної необхідно надати різні значення за умовою.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            <умова> ? <вираз, якщо умова істина> : <вираз, якщо умова хибна>\n                `}\n        </SyntaxHighlighter>\n        <p>Працює за такою схемою:</p>\n        <ul>\n          <li>\n            Обчислюється <span className={s.Span}>умова</span>\n          </li>\n          <li>\n            Якщо умова істинна, тобто наводиться до{\" \"}\n            <span className={s.Span}>true</span>, обчислюється вираз після{\" \"}\n            <span className={s.Span}>?</span>.\n          </li>\n          <li>\n            Якщо умова хибна, тобто наводиться до{\" \"}\n            <span className={s.Span}>false</span>, обчислюється вираз після{\" \"}\n            <span className={s.Span}>:</span>.\n          </li>\n          <li>\n            Значення обчисленого виразу повертається як наслідок роботи\n            тернарного оператора.\n          </li>\n        </ul>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            let type;\n            const age = 20;\n\n            if (age >= 18) {\n              type = \"adult\";\n            } else {\n              type = \"child\";\n            }\n\n            console.log(type); // \"adult\"\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Виконаємо рефакторинг замінивши{\" \"}\n          <span className={s.Span}>if...else</span> тернарним оператором.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            const age = 20;\n            const type = age >= 18 ? \"adult\" : \"child\";\n            console.log(type); // \"adult\"\n                `}\n        </SyntaxHighlighter>\n        <p>Запишемо операцію пошуку більшої кількості.</p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            const num1 = 5;\n            const num2 = 10;\n            let biggerNumber;\n\n            if (num1 > num2) {\n              biggerNumber = num1;\n            } else {\n              biggerNumber = num2;\n            }\n\n            console.log(biggerNumber); // 10\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Код працює правильно, отримуємо більше двох, але це рішення здається\n          занадто громіздким, враховуючи, наскільки проста проблема.\n          Використовуємо тернарний оператор.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            const num1 = 5;\n            const num2 = 10;\n            const biggerNumber = num1 > num2 ? num1 : num2;\n\n            console.log(biggerNumber); // 10\n                `}\n        </SyntaxHighlighter>\n        <div className={s.interestBox}>\n          <div className={s.interestHeader}>\n            <svg className={s.textIcon}>\n              <use href={sprite + \"#target\"}></use>\n            </svg>\n            <h5>ЦІКАВО</h5>\n          </div>\n          <p>\n            Тернарний оператор повинен використовуватись у простих операціях\n            присвоєння чи повернення. Його використання для опису складних\n            розгалужень – погана практика (антипаттерн).\n          </p>\n        </div>\n        <h1 id=\"switch\">Інструкція switch</h1>\n        <p>\n          У деяких випадках незручність читання складних розгалужень\n          <span className={s.Span}>if...else</span> можна уникнути,\n          використовуючи більш «плоский» синтаксис інструкції розгалуження{\" \"}\n          <span className={s.Span}>switch</span>.\n        </p>\n        <p>\n          Область застосування <span className={s.Span}>switch</span> обмежена\n          завданнями з одним загальним питанням (що порівнювати) та безліччю\n          варіантів відповідей (з чим порівнювати).\n        </p>\n        <div style={{ display: \"flex\", justifyContent: \"center\" }}>\n          <img src={switchImg} alt=\"\" />\n        </div>\n        <p>\n          Його синтаксис складається з блоку{\" \"}\n          <span className={s.Span}>switch</span>(значення)- що потрібно\n          порівняти та безлічі окремих випадків{\" \"}\n          <span className={s.Span}>case значення</span> - з чим потрібно\n          порівняти. Для порівняння використовується оператор строгої рівності{\" \"}\n          <span className={s.Span}>===</span>. Тобто не можна порівняти на\n          більше чи менше, лише на рівність.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            switch (значення) {\n              case значення:\n                інструкції;\n                break;\n\n              case значення:\n                інструкції;\n                break;\n\n              default:\n                інструкції;\n            }\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Значення в блоці <span className={s.Span}>switch (значення)</span> -\n          рядок або число, яке порівнюється на строгу рівність з усіма\n          значеннями в блоках <span className={s.Span}>case</span>\n          значениепо порядку зверху вниз.\n        </p>\n        <p>\n          Оператор <span className={s.Span}>break</span> в завершенні кожного\n          блоку <span className={s.Span}>case</span> необхідний щоб перервати\n          подальші перевірки і відразу перейти до коду{\" \"}\n          <span className={s.Span}>switch</span> в тому випадку, коли перевірка\n          на рівність повернула <span className={s.Span}>true</span>.\n        </p>\n        <p>\n          Якщо жодного збігу значень не відбулося, необхідно виконати за\n          замовчуванням код, як у блоці <span className={s.Span}>else</span> для\n          інструкції\n          <span className={s.Span}>if...else</span>. Для цього після всіх блоків{\" \"}\n          <span className={s.Span}>case</span> додається блок{\" \"}\n          <span className={s.Span}>default</span>. Оператор{\" \"}\n          <span className={s.Span}>break</span> після блоку{\" \"}\n          <span className={s.Span}>default</span> не потрібен, так як це і так\n          останнє, що буде виконано <span className={s.Span}>switch</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            let cost;\n            const subscription = \"SyntaxHighlightermium\";\n\n            switch (subscription) {\n              case \"free\":\n                cost = 0;\n                break;\n\n              case \"pro\":\n                cost = 100;\n                break;\n\n              case \"SyntaxHighlightermium\":\n                cost = 500;\n                break;\n\n              default:\n                console.log(\"Invalid subscription type\");\n            }\n\n            console.log(cost); // 500\n                `}\n        </SyntaxHighlighter>\n        <div className={s.interestBox}>\n          <div className={s.interestHeader}>\n            <svg className={s.textIcon}>\n              <use href={sprite + \"#target\"}></use>\n            </svg>\n            <h5>ЦІКАВО</h5>\n          </div>\n          <p>\n            Якщо оператор <span className={s.Span}>break</span> буде відсутній,\n            після того, як виконається якась умова{\" \"}\n            <span className={s.Span}>case</span>, всі наступні за ним блоки коду\n            будуть виконуватися один за одним, що може призвести до небажаних\n            наслідків при неправильному застосуванні.\n          </p>\n        </div>\n        <h1 id=\"fieldOfView\">Область видимості</h1>\n        <p>\n          <strong>Область видимості змінних (variable scope)</strong>–\n          доступність змінних у певному місці коду.\n        </p>\n        <p>\n          Глобальна область видимості використовується за умовчанням. Усі і всі\n          мають доступ до змінних оголошених у ній. Наприклад, змінна\n          <span className={s.Span}>value</span> оголошена у глобальній області\n          видимості, тобто поза якимось блоком, і доступна будь-де після\n          оголошення.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            const value = 5;\n\n            if (true) {\n                console.log(\"Block scope: \", value); // 5\n            }\n\n            console.log(\"Global scope: \", value); // 5\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Будь-яка конструкція використовує фігурні дужки{\" \"}\n          <span className={s.Span}>{}</span>(умови, цикли, функції тощо) створює\n          нову локальну область видимості, і змінні, оголошені в цій області\n          видимості, використовуючи <span className={s.Span}>let</span> або{\" \"}\n          <span className={s.Span}>const</span>, не доступні поза цим блоком.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            if (true) {\n                const value = 5;\n                console.log(\"Block scope: \", value); // 5\n            }\n\n            console.log(\"Global scope: \", value); // ReferenceError: value is not defined\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Глибина вкладеності областей видимості не обмежена, і всі вони\n          працюватиму за одним принципом - область видимості має доступ до всіх\n          змінних оголошених вище ієрархії вкладеності, але не може отримати\n          доступ до змінних оголошених у вкладених областях видимості.\n        </p>\n        <p>\n          Створимо кілька областей видимості та дамо їм імена для наочності.\n        </p>\n        <div style={{ display: \"flex\", justifyContent: \"center\" }}>\n          <img src={globalScope} alt=\"\" />\n        </div>\n        <ul>\n          <li>\n            Глобальна є за умовчанням, створимо в ній змінну{\" \"}\n            <span className={s.Span}>global</span>\n          </li>\n          <li>\n            Далі використовуючи оператор <span className={s.Span}>if</span>{\" \"}\n            створимо блокову область видимості{\" \"}\n            <span className={s.Span}>block A</span>\n          </li>\n          <li>\n            Усередині області видимості <span className={s.Span}>block A</span>{\" \"}\n            поставимо ще один оператор <span className={s.Span}>if</span>, який\n            створить вкладену область видимості{\" \"}\n            <span className={s.Span}>block B</span>\n          </li>\n          <li>\n            На одному рівні з <span className={s.Span}>block A</span>, створимо\n            область видимості\n            <span className={s.Span}>block C</span> так само використовуючи\n            оператор <span className={s.Span}>if</span>\n          </li>\n        </ul>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            const global = \"global\";\n\n            if (true) {\n              const blockA = \"block A\";\n\n              // Бачимо глобальну + локальну A\n              console.log(global); // 'global'\n              console.log(blockA); // block A\n\n              // Змінні blockB та blockC не знайдені в доступних областях видимості.\n              // Буде помилка заернення до змінної.\n              console.log(blockB); // ReferenceError: blockB is not defined\n              console.log(blockC); // ReferenceError: blockC is not defined\n\n              if (true) {\n                const blockB = \"block B\";\n\n                // Бачимо глобальну + зовнішню А + локальну В\n                console.log(global); // global\n                console.log(blockA); // block A\n                console.log(blockB); // block B\n\n                // Змінна blockC не знайдена в доступних областях видимості.\n                // Буде помилка звернення до змінної.\n                console.log(blockC); // ReferenceError: blockC is not defined\n              }\n            }\n\n            if (true) {\n              const blockC = \"block C\";\n\n              // Бачимо глобальну + локальну С\n              console.log(global); // global\n              console.log(blockC); // block C\n\n              // Змінні blockA та blockB не знайдені в доступних областях видимості.\n              // Буде помилка звернення до змінної.\n              console.log(blockA); // ReferenceError: blockA is not defined\n              console.log(blockB); // ReferenceError: blockB is not defined\n            }\n\n            // Бачимо лише глобальну\n            console.log(global); // global\n\n            // Змінні blockA, blockB та blockC не знайдені в доступних областях видимості.\n            // Буде помилка звернення до змінної.\n            console.log(blockA); // ReferenceError: blockA is not defined\n            console.log(blockB); // ReferenceError: blockB is not defined\n            console.log(blockC); // ReferenceError: blockC is not defined\n                `}\n        </SyntaxHighlighter>\n        <div className={s.interestBox}>\n          <div className={s.interestHeader}>\n            <svg className={s.textIcon}>\n              <use href={sprite + \"#target\"}></use>\n            </svg>\n            <h5>ЦІКАВО</h5>\n          </div>\n          <p>\n            Будьте уважні при використанні блокових областей видимості та\n            змінних оголошених у них. Саме ця помилка, разом із неуважністю,\n            часто стає головним болем новачка.\n          </p>\n        </div>\n        <h1 id=\"Cycles\">Цикли</h1>\n        <p>\n          Часте завдання програмування – виконання однотипної дії багато разів.\n          Наприклад, вивести клієнтів зі списку один за одним або перебрати суми\n          зарплат і для кожної виконати однаковий код. Саме для таких цілей –\n          багаторазового повторення однієї ділянки коду, використовуються цикли.\n        </p>\n        <ul>\n          <li>\n            <strong>Цикл</strong> - конструкція, що управляє, у високорівневих\n            мовах програмування, призначена для організації багаторазового\n            виконання набору інструкцій.\n          </li>\n          <li>\n            <strong>Тіло циклу</strong> – послідовність інструкцій, призначена\n            для багаторазового виконання.\n          </li>\n          <li>\n            <strong>Ітерація</strong> – одиничне виконання тіла циклу.\n          </li>\n          <li>\n            <strong>Умова виходу</strong> - вираз, що визначає вкотре\n            виконуватиметься ітерація, або цикл завершиться.\n          </li>\n          <li>\n            <strong>Лічильник</strong> – змінна, що зберігає поточний номер\n            ітерації. Цикл необов'язково містить лічильник, і не повинен бути\n            один, умова виходу з циклу може залежати від кількох змінних у циклі\n            змінних.\n          </li>\n        </ul>\n        <h2>\n          Цикл <span className={s.Span}>while</span>\n        </h2>\n        <p>\n          <strong>Цикл з передумовою</strong> - цикл, який виконується поки що\n          істинно деяка умова, вказана перед його початком. Ця умова\n          перевіряється до виконання тіла циклу, тому тіло може бути не виконане\n          жодного разу, якщо умова з самого початку є хибною.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n           while (condition) {\n              // код, тело цикла (statement)\n            }\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Конструкція <span className={s.Span}>while</span> створює цикл, який\n          виконує блок коду, доки умова перевірки оцінюється як{\" \"}\n          <span className={s.Span}>true</span>.\n        </p>\n        <ul>\n          <li>\n            <span className={s.Span}>condition</span>, тобто умова, що\n            обчислюється перед кожною ітерацією цику.\n          </li>\n          <li>\n            Якщо <span className={s.Span}>condition</span> оцінюється як{\" \"}\n            <span className={s.Span}>true</span>, оператор{\" \"}\n            <span className={s.Span}>while</span> виконує{\" \"}\n            <span className={s.Span}>statement</span>.\n          </li>\n          <li>\n            Якщо <span className={s.Span}>condition</span> оцінюється як{\" \"}\n            <span className={s.Span}>false</span>, виконання циклу переривається\n            і скрипт продовжує виконувати інструкції після циклу{\" \"}\n            <span className={s.Span}>while</span>.\n          </li>\n        </ul>\n        <p>\n          Блок-схема ілюструє цикл <span className={s.Span}>while</span>.\n        </p>\n        <div style={{ display: \"flex\", justifyContent: \"center\" }}>\n          <img src={WhileCicle} alt=\"\" />\n        </div>\n        <p>Зробимо лічильник.</p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            let counter = 0;\n\n            while (counter < 10) {\n              console.log(\"counter: \", counter);\n              counter += 1;\n            }\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Будемо заповнювати місця в готелі до тих пір, поки поточна кількість\n          клієнтів не буде максимально допустимою.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            let clientCounter = 18;\n            const maxClients = 25;\n\n            while (clientCounter < maxClients) {\n              console.log(clientCounter);\n              clientCounter += 1;\n            }\n                `}\n        </SyntaxHighlighter>\n        <h2>\n          Цикл <span className={s.Span}>do...while</span>\n        </h2>\n        <p>\n          <strong>Цикл з постумовою</strong> – цикл, у якому умова перевіряється\n          після виконання тіла циклу. Звідси випливає, що тіло завжди\n          виконується хоча б один раз.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            do {\n                // statement\n            } while (condition);\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Конструкція <span className={s.Span}>do...while</span> створює цикл,\n          який виконує блок коду, доки <span className={s.Span}>condition</span>{\" \"}\n          не поверне <span className={s.Span}>false</span>.\n        </p>\n        <p>\n          На відміну від циклу <span className={s.Span}>while</span> цикл{\" \"}\n          <span className={s.Span}>do...while</span> завжди виконує{\" \"}\n          <span className={s.Span}>statement</span> як мінімум один раз, перш\n          ніж він оцінить <span className={s.Span}>condition</span>.\n        </p>\n        <p>\n          Усередині циклу потрібно внести зміни до деякої змінної, щоб\n          переконатися, що вираз дорівнює <span className={s.Span}>false</span>{\" \"}\n          після ітерацій. В іншому випадку буде нескінченний цикл.\n        </p>\n        <p>\n          Блок-схема ілюструє цикл <span className={s.Span}>do-while</span>\n        </p>\n        <div style={{ display: \"flex\", justifyContent: \"center\" }}>\n          <img src={doWhile} alt=\"\" />\n        </div>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            let password = \"\";\n\n            do {\n              password = prompt(\"Введите пароль длиннее 4-х символов\", \"\");\n            } while (password.length < 5);\n\n            console.log(\"Ввели пароль: \", password);\n                `}\n        </SyntaxHighlighter>\n        <h2>\n          Цикл <span className={s.Span}>for</span>\n        </h2>\n        <p>\n          <strong>Цикл із лічильником</strong> - цикл, у якому деяка змінна\n          змінює своє значення від заданого початкового до кінцевого значення з\n          деяким кроком і для кожного значення цієї змінної тіло циклу\n          виконується один раз.\n        </p>\n        <p>\n          У більшості процедурних мов програмування реалізується конструкцією\n          <span className={s.Span}>for</span>, в якій вказується лічильник,\n          необхідна кількість ітерацій та крок, з яким змінюється лічильник.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            for (initialization; condition; post-exSyntaxHighlighterssion) {\n              // statements\n            }\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Алгоритм виконання циклу <span className={s.Span}>for</span>:\n        </p>\n        <ul>\n          <li>\n            <strong>Ініціалізація (initialization)</strong> – виконується один\n            раз перед початком циклу. Використовується для створення\n            змінної-лічильника та вказівки її початкового значення.\n          </li>\n          <li>\n            <strong>Умова (condition)</strong> – вираз, що оцінюється перед\n            кожною ітерацією (повторенням) циклу. Тіло циклу виконується лише\n            тоді, коли вираз наводиться до <span className={s.Span}>true</span>.\n            Цикл завершується, якщо значення буде{\" \"}\n            <span className={s.Span}>false</span>.\n          </li>\n          <li>\n            <strong>Тіло (statements)</strong> – набір інструкцій для виконання\n            на кожному повторенні. Виконується якщо вираз умови наводиться до\n            <span className={s.Span}>true</span>.\n          </li>\n          <li>\n            <strong>Пост-вираз (post-exssion)</strong> – виконується наприкінці\n            кожного повторення циклу, перед перевіркою умови. Використовується\n            для оновлення змінної-лічильника.\n          </li>\n        </ul>\n        <p>\n          Змінні-лічильники, за традицією, називаються буквами{\" \"}\n          <span className={s.Span}>i</span>,<span className={s.Span}>j</span> і{\" \"}\n          <span className={s.Span}>k</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            for (let i = 0; i <= 20; i += 5) {\n              console.log(i);\n            }\n                `}\n        </SyntaxHighlighter>\n        <p>\n          У прикладі оголошується змінна-лічильник{\" \"}\n          <span className={s.Span}>i</span>, ініціалізується значенням{\" \"}\n          <span className={s.Span}>0</span> і цикл виконується доти, поки{\" \"}\n          <span className={s.Span}>i</span>{\" \"}\n          <span className={s.Span}> ≤ 20</span>, тобто умова наводиться до{\" \"}\n          <span className={s.Span}>true</span>. Після кожної ітерації лічильник\n          збільшується на\n          <span className={s.Span}>5</span>.\n        </p>\n        <p>Порахуємо суму чисел до певного значення.</p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            const target = 3;\n            let sum = 0;\n\n            for (let i = 0; i <= target; i += 1) {\n              sum += i;\n            }\n\n            console.log(sum);\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Згадаймо про операцію <span className={s.Span}>a % b</span> і виведемо\n          залишок від поділу використовуючи цикл.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            const max = 10;\n            for (let i = 0; i < max; i += 1) {\n          }\n                `}\n        </SyntaxHighlighter>\n        <h2>\n          Оператор <span className={s.Span}>break</span>\n        </h2>\n        <p>\n          Перервати виконання циклу можна будь-якої миті. Для цього існує\n          оператор <span className={s.Span}>break</span>, який повністю припиняє\n          виконання циклу і передає управління на рядок за його тілом.\n        </p>\n        <p>\n          Знайдемо число <span className={s.Span}>3</span>. Як тільки\n          виконається умова <span className={s.Span}>if</span> цикл припинить\n          своє виконання (буде перерваний).\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            for (let i = 0; i <= 5; i += 1) {\n              console.log(i);\n\n              if (i === 3) {\n                console.log(\"Нашли число 3, прерываем выполнение цикла\");\n                break;\n              }\n            }\n\n            console.log(\"Лог после цикла\");\n                `}\n        </SyntaxHighlighter>\n        <h2>\n          Оператор <span className={s.Span}>continue</span>\n        </h2>\n        <p>\n          Перериває не весь цикл, лише виконання поточної ітерації. Його\n          використовують, якщо зрозуміло, що на поточній ітерації циклу робити\n          більше нічого або взагалі нічого робити не потрібно і настав час\n          переходити на наступну ітерацію.\n        </p>\n        <p>\n          Використовуємо цикл для виведення лише непарних чисел. Для парних\n          <span className={s.Span}>i</span> спрацьовує{\" \"}\n          <span className={s.Span}>continue</span> виконання тіла припиняється і\n          управління передається на наступну ітерацію.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            const number = 10;\n\n            for (let i = 0; i < number; i += 1) {\n              if (i % 2 === 0) {\n                continue;\n              }\n\n              console.log(\"Нечетное i: \", i); // 1, 3, 5, 7, 9\n            }\n                `}\n        </SyntaxHighlighter>\n      </div>\n    </div>\n  );\n};\n\nexport default M1L2;\n","/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/Lessons/GitHub.jsx",["99"],[],"import React from \"react\";\n\nconst GitHub = () => {\n    return (\n        <object data=\"\" type=\"\">\n            <iframe src=\"https://drive.google.com/file/d/1z-Rxcqq64ZKAhZlWoqgCRWRnOeXp-QQD/preview\" width=\"100%\" height=\"1200\" allow=\"autoplay\"></iframe>\n\n        </object>\n    )\n\n}\nexport default GitHub","/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/Lessons/M1L1.jsx",["100","101","102","103"],[],"import React from \"react\";\nimport s from \"./Lessons.module.css\";\nimport sprite from \"../../img/icomoon/sprite.svg\";\nimport table1 from \"../../img/table1.png\";\nimport table2 from \"../../img/table2.png\";\nimport operatorTable1 from \"../../img/not-strict-equality.png\";\nimport operatorTable2 from \"../../img/strict-equality.png\";\nimport string from \"../../img/string-idx.png\";\nimport code1 from \"../../img/code1.png\";\nimport booleanOperators from \"../../img/boolean-operators.png\";\nimport Scrollspy from \"react-scrollspy\";\nimport { Prism as SyntaxHighlighter } from \"react-syntax-highlighter\";\nimport { materialDark } from \"react-syntax-highlighter/dist/esm/styles/prism\";\n\nconst M1L1 = () => {\n  const codeStyle = materialDark;\n\n  return (\n    <div className={s.lessonsBox}>\n      <div className={s.breadNav}>\n        <Scrollspy\n          items={[\n            \"section-1\",\n            \"section-2\",\n            \"section-3\",\n            \"section-4\",\n            \"section-5\",\n            \"section-6\",\n            \"section-7\",\n            \"section-8\",\n            \"section-9\",\n          ]}\n          currentClassName=\"is-current\"\n        >\n          <div className={s.breadNavList}>\n            <li>\n              <a href=\"#section-1\">Підключення скрипту</a>\n            </li>\n            <li>\n              <a href=\"#section-2\">Інструменти розробника</a>\n            </li>\n            <li>\n              <a href=\"#section-3\">Основи синтаксису</a>\n            </li>\n            <li>\n              <a href=\"#section-4\">Змінні та типи</a>\n            </li>\n\n            <li>\n              <a href=\"#section-5\">Взаємодія з користувачем</a>\n            </li>\n\n            <li>\n              <a href=\"#section-6\">Основні оператори</a>\n            </li>\n            <li>\n              <a href=\"#section-7\">Числа</a>\n            </li>\n            <li>\n              <a href=\"#section-8\">Рядки</a>\n            </li>\n            <li>\n              <a href=\"#section-9\">Логічні оператори</a>\n            </li>\n          </div>\n        </Scrollspy>\n      </div>\n\n      <div className={s.article}>\n        <h1>Знайомство з JavaScript</h1>\n        <p>\n          Коли ми говоримо про програмування, перше, що спадає на думку це набір\n          інструкцій у файлі. Вихідний код (source code) - це текст комп'ютерної\n          програми будь-якою мовою програмування, набір синтаксичних\n          конструкцій, що легко читають, що описують набір інструкцій для\n          комп'ютера.\n        </p>\n\n        <p>\n          Сам собою вихідний код незрозумілий для машини. Є крок, що виконується\n          після написання програми, який конвертує вихідний код у файлі набір\n          інструкцій зрозумілих комп'ютеру. Цим займається спеціальна програма:\n          компілятор чи інтерпретатор . Звідси можна дійти невтішного висновку -\n          код пишеться задля машини, а розробника. Вихідний код повинен як\n          правильно вирішувати завдання, а й бути зрозумілим.\n        </p>\n\n        <h3>Логічне мислення</h3>\n        <p>\n          У світі є багато мов програмування. Вони не такі складні, як людські,\n          тому що складаються з досить маленького набору синтаксичних\n          конструкцій, а принцип роботи і базові концепції схожі між різними\n          мовами.\n        </p>\n        <p>\n          Досвідчені розробники розглядають проблеми з погляду алгоритмів -\n          набору кроків, які потрібно виконати задля досягнення певної мети. Ми\n          постійно використовуємо алгоритми у повсякденному житті. Наприклад,\n          процес приготування чаю – це набір необхідних кроків (алгоритм) задля\n          досягнення результату. Коли ви звикнете вибудовувати рішення задачі у\n          вигляді алгоритму, мова програмування буде лише інструментом.\n        </p>\n\n        <p>\n          <span className={s.Span}>JavaScript</span> - реалізація специфікації\n          EcmaScript, високорівнева мова програмування, яку підтримують всі\n          сучасні веб-браузери. Спочатку призначений для взаємодії з елементами\n          веб-сторінок та додавання інтерактивності.\n        </p>\n\n        <div className={s.interestBox}>\n          <div className={s.interestHeader}>\n            <svg className={s.textIcon}>\n              <use href={sprite + \"#target\"}></use>\n            </svg>\n            <h5>ЦІКАВО</h5>\n          </div>\n          <p>\n            JavaScript немає жодного відношення до мови Java. Це дві незалежні\n            мови програмування.\n          </p>\n        </div>\n\n        <p>\n          При Front-end розробці JavaScript використовується у зв'язці з HTML та\n          CSS для забезпечення функціональності веб-сторінки, такої як:\n        </p>\n        <ul>\n          <li>нескладні обчислення</li>\n          <li>перевірка та маніпуляція введеними користувачем даними</li>\n          <li>зберігання інформації у браузері користувача</li>\n          <li>динамічна зміна HTML-документа</li>\n          <li>реакція на дії користувача</li>\n          <li>створення інтерактивних елементів: галерей, графіків тощо.</li>\n          <li>взаємодія з бекендом</li>\n        </ul>\n\n        <div className={s.interestBox}>\n          <div className={s.interestHeader}>\n            <svg className={s.textIcon}>\n              <use href={sprite + \"#target\"}></use>\n            </svg>\n            <h5>ЦІКАВО</h5>\n          </div>\n          <p>\n            Якщо JavaScript-код пишеться для виконання в браузері (Front-end),\n            розробник не має інструментів і доступу до файлової або операційної\n            системи з міркувань безпеки.\n          </p>\n        </div>\n\n        <p>На сьогоднішній день використовуючи JavaScript можна створювати:</p>\n\n        <ul>\n          <li>веб-додатки на фреймворках React, Vue, Angular та інших</li>\n          <li>бекенд програми на Node.js</li>\n          <li>мобільні програми на React Native або Ionic</li>\n          <li>десктоп програми за допомогою Electron</li>\n          <li>мікроконтролери з Johnny-FiveіEspruino</li>\n        </ul>\n        <p>\n          Для реалізації всіх цих можливостей необхідно добре знати синтаксис\n          мови, його особливості та механізми, тренуватися мислити алгоритмічно\n          та вирішувати якнайбільше практичних завдань.\n        </p>\n        <h1 id=\"section-1\">Підключення скрипту</h1>\n        <p>\n          Щоб додати скрипт на веб-сторінку в HTML-файлі, використовується тег{\" \"}\n          <span className={s.Span}>script</span> , в атрибуті{\" \"}\n          <span className={s.Span}>src</span> якого вказуємо посилання на\n          зовнішній JavaScript-файл.\n        </p>\n        <p>Щоб підключити JavaScript із зовнішнього файлу:</p>\n        <ul>\n          <li>\n            Створіть файл із розширенням <span className={s.Span}>.js</span> і\n            помістіть його в підпапку <span className={s.Span}>js</span>.\n          </li>\n          <li>\n            Потім вкажіть шлях до файлу скрипта в атрибуті{\" \"}\n            <span className={s.Span}>src</span> тега{\" \"}\n            <span className={s.Span}>script</span> .\n          </li>\n        </ul>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n              <!DOCTYPE html>\n              <html lang=\"en\">\n                  <head>\n                      <meta charset=\"UTF-8\" />\n                      <title>JavaScript is fun!</title>\n                  </head>\n\n                  <body>\n                      <!-- контент -->\n                      <script src=\"js/script.js\"></script>\n                  </body>\n              </html>\n            `}\n        </SyntaxHighlighter>\n        <div className={s.interestBox}>\n          <div className={s.interestHeader}>\n            <svg className={s.textIcon}>\n              <use href={sprite + \"#target\"}></use>\n            </svg>\n            <h5>ЦІКАВО</h5>\n          </div>\n          <p>\n            Розміщення JavaScript файлу в папці{\" \"}\n            <span className={s.Span}>js</span> не потрібне, але це хороша\n            практика.\n          </p>\n        </div>\n        <p>\n          Якщо скрипт підключено до <span className={s.Span}>{`<head>`}</span>,\n          відображення сторінки зупиняється, доки скрипт не завантажиться та\n          виконається повністю. Браузер завантажує та відображає HTML поступово.\n          Якщо він бачить тег <span className={s.Span}>{`<script>`}</span> без\n          додаткових атрибутів, то спочатку виконується скрипт і потім\n          обробляється решта код HTML-файлу. Тому скрипт підключають перед\n          тегом, що закриває <span className={s.Span}>{`<body>`}</span>, після\n          всього вмісту, як у прикладі.\n        </p>\n\n        <h3>Підключення декількох скриптів</h3>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n              <script src=\"js/script-1.js\"></script>\n              <script src=\"js/script-2.js\"></script>\n            `}\n        </SyntaxHighlighter>\n        <h1 id=\"section-2\">Інструменти розробника</h1>\n        <p>\n          При написанні коду завжди будуть оповіщення та помилки, це нормально.\n          Консоль браузера показує інформацію, пов'язану з веб-сторінкою, у тому\n          числі повідомлення про помилки та попередження виконання JS-коду,\n          запущеного в контексті сторінки.\n        </p>\n        <p>\n          Наступні комбінації клавіш відкривають інструменти розробника на\n          вкладці <span className={s.Span}>Console:</span>{\" \"}\n        </p>\n        <ul>\n          <li>\n            Windows та Linux - <span className={s.Span}>Ctrl</span> +{\" \"}\n            <span className={s.Span}>Shift</span> +{\" \"}\n            <span className={s.Span}>J</span> aбо{\" \"}\n            <span className={s.Span}>F12</span>{\" \"}\n          </li>\n          <li>\n            MacOS - <span className={s.Span}>Command</span> +{\" \"}\n            <span className={s.Span}>Option</span> +\n            <span className={s.Span}>J</span>{\" \"}\n          </li>\n        </ul>\n        <h3>Додаткові матеріали</h3>\n\n        <div className={s.link}>\n          <a\n            target=\"_blank\"\n            href=\"https://developer.chrome.com/docs/devtools/console/api/\"\n          >\n            Довідник по API консолі\n          </a>\n          <a\n            target=\"_blank\"\n            href=\"https://developer.chrome.com/docs/devtools/console/log/\"\n          >\n            Виведення повідомлень у консоль\n          </a>\n        </div>\n\n        <h1 id=\"section-3\">Основи синтаксису</h1>\n        <p>\n          При написанні коду важливо не просто знати, який символ або\n          конструкцію можна використовувати, але в першу чергу необхідно\n          розуміти термінологію та складові вихідного коду. У цій секції нам не\n          важливе розуміння як що працює, ми лише познайомимося з базовою\n          термінологією та синтаксисом.\n        </p>\n        <h3>Інструкція</h3>\n        <p>\n          <strong>Інструкція (statement) </strong> - це пов'язаний набір слів та\n          символів із синтаксису мови, які поєднуються щоб висловити одну ідею,\n          одну інструкцію для машини.\n        </p>\n\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            a = b * 2;\n            `}\n        </SyntaxHighlighter>\n        <p>\n          Інструкції в JavaScript закінчуються крапкою з комою, яку можна\n          порівняти з крапкою в кінці речення вашої рідної мови.\n        </p>\n        <ul>\n          <li>\n            {\" \"}\n            <span className={s.Span}>a</span> і{\" \"}\n            <span className={s.Span}>b</span> - змінні (як в рівнянні алгебри),\n            це сховища даних, які використовує програма. Змінна складається з\n            ідентифікатора (імені) та пов'язаного з ним значення.\n          </li>\n          <li>\n            <span className={s.Span}>2</span> - Просто число. Це називається\n            значенням літералу (literal value), тому що не зберігається у\n            змінній.\n          </li>\n          <li>\n            <span className={s.Span}>=</span>і <span className={s.Span}>*</span>{\" \"}\n            - оператори, що роблять дії над значеннями та змінними.\n          </li>\n        </ul>\n        <p>\n          Уявімо, що змінна <span className={s.Span}>b</span> вже зберігає число{\" \"}\n          <span className={s.Span}>10</span>. Тоді ця інструкція каже машині:\n        </p>\n        <ol>\n          <li>\n            Піди знайди змінну з ідентифікатором{\" \"}\n            <span className={s.Span}>b</span> і запитай, яке в неї зараз\n            значення.\n          </li>\n          <li>\n            Підстав значення змінної <span className={s.Span}>b</span>(10) у\n            затвердження на місце <span className={s.Span}>b</span>\n          </li>\n          <li>\n            Виконай операцію множення <span className={s.Span}>10</span> на{\" \"}\n            <span className={s.Span}>2</span>.\n          </li>\n          <li>\n            Запиши результат обчислення вираження правої частини змінну{\" \"}\n            <span className={s.Span}>a</span>.\n          </li>\n        </ol>\n        <div className={s.interestBox}>\n          <div className={s.interestHeader}>\n            <svg className={s.textIcon}>\n              <use href={sprite + \"#target\"}></use>\n            </svg>\n            <h5>ЦІКАВО</h5>\n          </div>\n          <p>\n            Завершення інструкції крапкою з комою не потрібно, проте{\" \"}\n            <strong>рекомендується</strong> завжди її ставити. Це просте правило\n            зробить код зрозумілішим і допоможе уникнути неочевидних помилок.\n          </p>\n        </div>\n\n        <h3>Вираз</h3>\n        <p>\n          Інструкції складаються з частин, як у будь-якій мові речення\n          складаються із фраз, і ці фрази називаються виразами\n        </p>\n        <p>\n          <strong>Вираз (exssion) </strong>- посилання змінну чи значення, чи\n          набір змінних і значень разом із операторами.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            [ [a] = [ [b] * [2] ] ]\n            `}\n        </SyntaxHighlighter>\n        <p>\n          Інструкція з прикладу містить 5 виразів, які виділені квадратними\n          дужками для візуалізації ( це не синтаксис мови ):\n        </p>\n        <ul>\n          <li>\n            <span className={s.Span}>[2]</span>- Вираз значення літералу.\n          </li>\n          <li>\n            <span className={s.Span}>[b]</span> і{\" \"}\n            <span className={s.Span}>[a]</span>- вирази змінної, означають\n            необхідність підставити значення змінної, але у тому разі, якщо\n            змінна стоїть у правій частині висловлювання присвоювання.\n          </li>\n          <li>\n            <span className={s.Span}>[b * 2]</span>- арифметичний вираз\n            множення.\n          </li>\n          <li>\n            <span className={s.Span}>[a = b * 2]</span>- Вираз привласнення. У\n            нашому випадку вказує на необхідність обчислення правої частини\n            виразу та привласнення результату змінної{\" \"}\n            <span className={s.Span}>a</span> у лівій частині виразу.\n          </li>\n        </ul>\n        <p>\n          Також є вирази виклику, порівняння і т. д. Ми не будемо зараз\n          розглядати їх усі, нам важливо розуміти, з яких частин складається\n          вихідний код і як правильно читати його.\n        </p>\n        <h3>Інтерфейс</h3>\n        <p>\n          Коли ми підходимо до автомата з кавою або сідаємо за кермо автомобіля,\n          існує певний набір елементів керування, з яким можна взаємодіяти. У\n          програмуванні це називається інтерфейс.\n        </p>\n        <p>\n          <strong>Інтерфейс</strong> - це набір властивостей та методів\n          сутності, доступних для використання у вихідному коді.\n        </p>\n        <h3>Властивість</h3>\n        <p>\n          У нас з вами є властивості: зріст, вага, колір очей, тобто якісь\n          описові характеристики. Так само і у даних є властивості, наприклад,\n          рядок має властивість його довжини. Синтаксис звернення до властивості\n          дуже простий – через крапку.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n           сутність.ім'я_властивості\n            `}\n        </SyntaxHighlighter>\n        <p>\n          Для наочності звернемося до якості рядка{\" \"}\n          <span className={s.Span}>length</span>, яке містить кількість символів\n          рядка.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n           \"JavaScript is awesome\".length;\n            `}\n        </SyntaxHighlighter>\n        <h3>Метод</h3>\n        <p>\n          Це виклик дії, наприклад , <span className={s.Span}>присісти</span>{\" \"}\n          або <span className={s.Span}>бігати</span>, тобто якась активна\n          операція. Так само і у даних є свої заздалегідь визначені методи,\n          наприклад, можна додати або видалити елементи з колекції, перевести\n          рядок у різний регістр і т. д. Синтаксис виклику методу дуже схожий на\n          звернення до властивості, але в кінці додається пара круглих дужок.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n                    сутність.ім'я_метода()\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Наприклад звернемося до методу рядка{\" \"}\n          <span className={s.Span}>toUpperCase()</span> , який зробить усі\n          літери великими.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n                    \"JavaScript is awesome\".toUpperCase();\n                `}\n        </SyntaxHighlighter>\n        <h3>Суворий режим написання коду</h3>\n        <p>\n          Нова можливість специфікації ECMAScript 5, яка дозволяє переводити\n          скрипт в режим повної відповідності сучасному стандарту. Це запобігає\n          певним помилкам, таким як використання небезпечних і застарілих\n          конструкцій.\n        </p>\n        <p>\n          Щоб перевести скрипт у строгий режим, достатньо вказати директиву на\n          початку js-файлу. Завжди пишіть код у строгому режимі.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n                   script.js\n                   \"use strict\";\n                   // Це коментар. Далі йде весь код JS-файлу\n                `}\n        </SyntaxHighlighter>\n\n        <h1 id=\"section-4\">Змінні та типи</h1>\n        <p>\n          Змінні використовуються для зберігання даних і складаються з\n          ідентифікатора (імені) та області пам'яті, де зберігається їх\n          значення. Змінну можна як коробку з назвою, у якій щось лежить\n          (значення).\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n                  <ключове_слово> <ім'я_змінної> = <значення>\n                `}\n        </SyntaxHighlighter>\n        <h3>Імена зміних</h3>\n        <p>\n          <strong>Ідентифікатор</strong> – це ім'я змінної, функції або класу.\n          Складається з одного або кількох символів у наступному форматі.\n        </p>\n        <ul>\n          <li>\n            Першим символом має бути буква <span className={s.Span}>a-z</span>{\" \"}\n            або <span className={s.Span}>A-Z</span>\n            символ підкреслення <span className={s.Span}>_</span> або знак\n            долара <span className={s.Span}>$</span>.\n          </li>\n          <li>\n            Інші символи можуть бути літерами <span className={s.Span}>-z</span>\n            , <span className={s.Span}>-Z</span>\n            цифрами <span className={s.Span}>0-9</span>, підкресленнями{\" \"}\n            <span className={s.Span}>_</span> та знаками долара{\" \"}\n            <span className={s.Span}>$</span> .\n          </li>\n          <li>\n            Ідентифікатори чутливі до регістру. Це означає, що змінні{\" \"}\n            <span className={s.Span}>user</span> та{\" \"}\n            <span className={s.Span}>usEr</span>,{\" \"}\n            <span className={s.Span}>User</span> різні\n          </li>\n        </ul>\n        <p>Ім'я змінної має бути зрозумілим.</p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n                 # ❌ Погано\n                 chislo\n                 korzina_tovariv\n                 profil_koristuvacha\n                 potochni_misyac\n                 \n                 # ✅ Добре\n                 number\n                 cart\n                 userProfile\n                 currentMonth\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Використання camelCase-нотації для ідентифікаторів є стандартом. Перше\n          слово пишеться малими літерами, а кожне наступне починається з\n          великої. Наприклад, <span className={s.Span}>user</span>,{\" \"}\n          <span className={s.Span}>getUserData</span> ,{\" \"}\n          <span className={s.Span}>isActive</span>,{\" \"}\n          <span className={s.Span}>activeGuestCount</span>.\n        </p>\n        <div className={s.link}>\n          <a target=\"_blank\" href=\"https://bookflow.ru/kak-nazyvat-peremennye/\">\n            Як називати змінні\n          </a>\n          <a\n            target=\"_blank\"\n            href=\"https://www.freecodecamp.org/news/javascript-naming-conventions-dos-and-don-ts-99c0e2fdd78a\"\n          >\n            Угоди про імена змінні\n          </a>\n        </div>\n        <h3>Ключові слова</h3>\n        <p>\n          Є список зарезервованих ключових слів, які мають особливе значення і\n          використовуються для певних конструкцій. Не можна використовувати\n          ключові слова як ідентифікатори.\n        </p>\n        <div>\n          <img src={table1} alt=\"\" />\n          <img src={table2} alt=\"\" />\n        </div>\n        <h3>Оголошення змінних</h3>\n        <p>\n          Оголошення змінної починається з ключового слова{\" \"}\n          <span className={s.Span}>const</span>. Така змінна має бути відразу\n          ініціалізована значенням, після чого його не можна перевизначити.\n        </p>\n\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n                 // Змінні, об'явленні як const, обов'язково мають бути ініціалізовані\n                 // значенням під час оголошення, інакше буде помилка.\n                 const yearOfBirth = 2006;\n                 console.log(yearOfBirth); // 2006\n                 \n                 // Якщо змінну оголошено як const, перезаписати її значення не можна.\n                 // При спробі надати нове значення будеш помилка виконання скрипта.\n                 yearOfBirth = 2020; // ❌ Неправильно, буде помилка\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Для того, щоб оголосити змінну, якій у майбутньому можна буде надати\n          нове значення, використовується ключове слово{\" \"}\n          <span className={s.Span}>let</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n                 // Переменным, объявленным через let, не обязательно сразу присваивать значение.\n                 let age;\n                 \n                 // Якщо змінної, оголошеної як let, спочатку не надано значення,\n                 // вона ініціалізується спеціальним значенням undefined (не визначено).\n                 console.log(age); // undefined\n                 \n                 // console.log() це метод для виведення даних у консоль браузера,\n                 // детальніше з ним познайомимося пізніше.\n                 \n                 // Якщо змінна оголошена як let, її значення можна перезаписати.\n                 age = 14;\n                 console.log(age); // 14\n                `}\n        </SyntaxHighlighter>\n        <div className={s.interestBox}>\n          <div className={s.interestHeader}>\n            <svg className={s.textIcon}>\n              <use href={sprite + \"#target\"}></use>\n            </svg>\n            <h5>ЦІКАВО</h5>\n          </div>\n          <p>\n            Оголошення змінної без ключового слова{\" \"}\n            <span className={s.Span}>let</span> або{\" \"}\n            <span className={s.Span}>const</span> призведе до помилки, якщо\n            скрипт виконується у строгому режимі.\n          </p>\n        </div>\n        <h3>\n          Коли використовувати <span className={s.Span}>const</span>, а коли{\" \"}\n          <span className={s.Span}>let</span>\n        </h3>\n        <p>\n          Єдина відмінність <span className={s.Span}>const</span> і{\" \"}\n          <span className={s.Span}>let</span> полягає в тому, що{\" \"}\n          <span className={s.Span}>const</span> забороняє повторне надання\n          змінної будь-якого значення. Оголошення{\" \"}\n          <span className={s.Span}>const</span> робить код більш читаним,\n          оскільки змінна завжди посилається на те саме значення. У разі{\" \"}\n          <span className={s.Span}>let</span> такої впевненості немає.\n        </p>\n        <h3>Константи, які не змінюються</h3>\n        <p>\n          Імена <strong>КОНСТАНТ</strong> - змінних, значення яких ніколи не\n          змінюється протягом роботи всього скрипта, зазвичай записуються у\n          форматі <span className={s.Span}>UPPER_SNAKE_CASE</span> .\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n                 // Константа, яка зберігає код кольору\n                 const COLOR_TEAL = \"#009688\";\n                 \n                 // Константа, ка зберігає повідомлення про результат авторизації\n                 const LOGIN_SUCCESS_MESSAGE = \"Вітаю! Ви успішно авторизувались\";\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Абсолютна більшість змінних - константи в іншому сенсі, вони просто не\n          змінюють значення після присвоєння. Але при різних запусках скрипта це\n          значення може бути різним. Імена таких змінних записують за допомогою\n          формату <span className={s.Span}>camelCase</span>.\n        </p>\n\n        <h3>Звернення до зміної</h3>\n        <p>Важливо розрізняти невизначені та неоголошені змінні.</p>\n        <p>\n          <strong>Невизначена (undefined)</strong> - це змінна, яка була\n          оголошена ключовим словом <span className={s.Span}>let</span>, але не\n          ініціалізована значенням. За умовчанням їй надається початкове\n          значення <span className={s.Span}>undefined</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n                 let username;\n                 console.log(username); // undefined\n                `}\n        </SyntaxHighlighter>\n        <p>\n          <strong>Неоголошена (undeclared чи not defined)</strong> - це змінна,\n          яка була оголошена у доступній області видимості. Спроба звернутися до\n          придбаної до її оголошення викликає помилку. Наприклад, щоб прочитати\n          чи змінити її значення.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n                 // ❌ Неправильно, буде помилка\n                 age = 15; // ReferenceError: Cannot access 'age' before initialization\n                 console.log(age); // ReferenceError: age is not defined\n                 \n                 // Оголошення змінної age\n                 let age = 20;\n                 \n                 // ✅ Правильно, звертаємось після оголошення\n                 age = 25;\n                 console.log(age); // 25\n                `}\n        </SyntaxHighlighter>\n        <h3>Примітивні типи</h3>\n        <p>\n          У JavaScript змінна не асоціюється з будь-яким типом даних, тип має її\n          значення. Тобто змінна може зберігати значення різних типів.\n        </p>\n        <p>\n          <strong>Number</strong> - цілі числа та числа з плаваючою комою\n          (крапкою).\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            const age = 20;\n            const points = 15.8;\n                `}\n        </SyntaxHighlighter>\n        <p>\n          <strong>String</strong> - рядки, послідовність із нуля або більше\n          символів. Рядок починається і закінчується одиночною{\" \"}\n          <span className={s.Span}>'</span>, або подвійними лапками{\" \"}\n          <span className={s.Span}>\"</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n           const username = \"Nik\";\n           const description = \"JavaSript для початківців\";\n                `}\n        </SyntaxHighlighter>\n\n        <p>\n          <strong>Boolean</strong> – логічний тип даних, прапори стану. Усього\n          два значення: true і false. Наприклад, на запитання включено світло в\n          кімнаті можна відповісти так (true) чи ні (false).\n        </p>\n        <ul>\n          <li>\n            <span className={s.Span}>true</span> - так, мабуть, істина, 1\n          </li>\n          <li>\n            <span className={s.Span}>false</span>- ні, невірно, брехня, 0\n          </li>\n        </ul>\n        <p>\n          <strong>null</strong> - особливе значення, яке по суті означає ничто.\n          Використовується в тих ситуаціях, коли необхідно вказати порожнечу.\n          Наприклад, якщо користувач ще нічого не вибрав, то можна сказати що\n          значення <span className={s.Span}>null</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          let selectedProduct = null;\n                `}\n        </SyntaxHighlighter>\n        <p>\n          <strong>undefined</strong> – ще одне спеціальне значення. За\n          умовчанням, коли змінна оголошується, але з ініціалізується, її\n          значення визначено, їй присвоюється{\" \"}\n          <span className={s.Span}>undefined</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n           let username;\n           console.log(username); // undefined\n                `}\n        </SyntaxHighlighter>\n        <h3>\n          Оператор <span className={s.Span}>typeof</span>\n        </h3>\n        <p>\n          Використовується для отримання типу змінної. Повертає місце свого\n          виклику тип значення змінної зазначеного після нього - рядок у якому\n          зазначений тип.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          let username;\n          console.log(typeof username); // \"undefined\"\n          \n          let inputValue = null;\n          console.log(typeof inputValue); // \"object\"\n          \n          const quantity = 17;\n          console.log(typeof quantity); // \"number\"\n          \n          const message = \"JavaScript is awesome!\";\n          console.log(typeof message); // \"string\"\n          \n          const isSidebarOpen = false;\n          console.log(typeof isSidebarOpen); // \"boolean\"\n                `}\n        </SyntaxHighlighter>\n        <h1 id=\"section-5\">Взаємодія з користувачем</h1>\n        <p>\n          Розберемо базові операції введення/виводу, достатні для отримання та\n          відображення даних від користувача, перш ніж навчимося працювати з\n          HTML-документом.\n        </p>\n        <h3>Виведення даних (відтворення)</h3>\n        <p>\n          Для виведення даних є два методи:{\" \"}\n          <span className={s.Span}>console.log()</span>і{\" \"}\n          <span className={s.Span}>alert()</span>. У круглих дужках вказуємо\n          ім'я змінної, значення якої потрібно вивести.\n        </p>\n\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n                const message = \"JavaScript is awesome!\";\n                console.log(message); // JavaScript is awesome!\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Можна спочатку вказати якийсь описовий рядок, після чого поставити\n          кому і вказати ім'я змінної.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n               const username = \"Nik\";\n               console.log(\"Username is \", username); // Username is Nik\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Метод <span className={s.Span}>alert()</span> виводить модальне вікно,\n          текст якого відповідає значенню змінної (або літералу), яку передамо в\n          дужках.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n               const message = \"JavaScript is awesome!\";\n               alert(message);\n                `}\n        </SyntaxHighlighter>\n        <div className={s.interestBox}>\n          <div className={s.interestHeader}>\n            <svg className={s.textIcon}>\n              <use href={sprite + \"#target\"}></use>\n            </svg>\n            <h5>ЦІКАВО</h5>\n          </div>\n          <p>\n            <span className={s.Span}>console</span> і{\" \"}\n            <span className={s.Span}>alert</span> є частиною інтерфейсу{\" \"}\n            <span className={s.Span}>window</span> – глобального об'єкта,\n            доступного під час виконання скрипту на веб-сторінці. Запис{\" \"}\n            <span className={s.Span}>window.alert()</span> надлишковий, пишемо\n            просто <span className={s.Span}>alert()</span> або{\" \"}\n            <span className={s.Span}>console.log()</span>. Детальніше про це\n            говоритимемо далі в курсі.\n          </p>\n        </div>\n        <a href=\"https://medium.com/free-code-camp/how-to-use-the-javascript-console-going-beyond-console-log-5128af9d573b\">\n          Як використовувати <strong>console.log()</strong>{\" \"}\n        </a>\n        <h3>Отримання даних</h3>\n        <p>\n          Для отримання даних від користувача{\" \"}\n          <span className={s.Span}>prompt()</span> є{\" \"}\n          <span className={s.Span}>confirm()</span>. Це також методи з\n          інтерфейсу <span className={s.Span}>window</span>. Результатом свого\n          виконання вони повертають те, що було введено користувачем, тому\n          результат роботи можна записати в змінну для подальшого використання.\n        </p>\n        <p>\n          <span className={s.Span}>confirm()</span> - Виводить модальне вікно з\n          повідомленням, і дві кнопки, <span className={s.Span}>Ok</span> і{\" \"}\n          <span className={s.Span}>Cancel</span>. При натисканні на{\" \"}\n          <span className={s.Span}>Ok</span> , результатом буде{\" \"}\n          <span className={s.Span}>true</span> при натисканні на{\" \"}\n          <span className={s.Span}>Cancel</span> - повертається{\" \"}\n          <span className={s.Span}>false</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n               // Просимо клієнта підтвердити бронювання в готелі\n               // та зберігаємо в змінну результат роботи confirm\n               const isComing = confirm(\"Please confirm hotel reservation\");\n               console.log(isComing);\n                `}\n        </SyntaxHighlighter>\n        <p>\n          <span className={s.Span}>prompt()</span> - Виводить модальне вікно з\n          полем введення та кнопками <span className={s.Span}>Ok</span> і{\" \"}\n          <span className={s.Span}>Cancel</span>. При натисканні{\" \"}\n          <span className={s.Span}></span>, результатом буде те, що ввів\n          користувач, <span className={s.Span}>Cancel</span> повертається{\" \"}\n          <span className={s.Span}>null</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n              // Запитуємо назву готеля, в якому хотів би зупинитися клієнт\n              // та зберігаємо в змінну результат виклику prompt.\n              const hotelName = prompt(\"Please enter desired hotel name\");\n              console.log(hotelName);\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Важлива особливість <span className={s.Span}>prompt</span> у тому, що\n          незалежно від того, що ввів користувач, завжди повернеться рядок.\n          Тобто якщо користувач ввів 5, то повернеться не число 5, а рядок \"5\".\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n              const value = prompt(\"Please enter a number!\");\n              console.log(typeof value); // \"string\"\n              console.log(value); // \"5\"\n                `}\n        </SyntaxHighlighter>\n        <h1 id=\"section-6\">Основні оператори</h1>\n        <h3>Математичні оператори</h3>\n        <p>\n          Призначення, функціонал та пріоритет (порядок) операцій нічим не\n          відрізняються від шкільного курсу алгебри. Оператори повертають\n          значення як наслідок висловлювання.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n              const x = 10;\n              const y = 5;\n              \n              // Додавання\n              console.log(x + y); // 15\n              \n              // Віднімання\n              console.log(x - y); // 5\n              \n              // Множення\n              console.log(x * y); // 50\n              \n              // Ділення\n              console.log(x / y); // 2\n              \n              // Залишок від ділення\n              console.log(x % y); // 0\n              \n              // Додавання з заміною (також є для всіх інших операторів)\n              let value = 5;\n              \n              // Аналогично запису value = value + 10;\n              value += 10;\n              console.log(value); // 15\n                `}\n        </SyntaxHighlighter>\n        <div className={s.interestBox}>\n          <div className={s.interestHeader}>\n            <svg className={s.textIcon}>\n              <use href={sprite + \"#target\"}></use>\n            </svg>\n            <h5>ЦІКАВО</h5>\n          </div>\n          <p>\n            Важливо запам'ятати терміни виразів.{\" \"}\n            <span className={s.Span}> + - * / %</span> називаються{\" \"}\n            <strong>оператори</strong> , а те, на чому вони застосовуються –{\" \"}\n            <strong>операнди</strong> .\n          </p>\n        </div>\n        <h3>Оператори порівняння</h3>\n        <p>\n          Використовуються для порівняння двох значень. Результатом свого\n          виконання повертають буль- <span className={s.Span}>true</span> або{\" \"}\n          <span className={s.Span}>false</span>, тобто «так» чи «ні».\n        </p>\n        <ul>\n          <li>\n            <span className={s.Span}>{`a > b`}</span> і{\" \"}\n            <span className={s.Span}>{`a < b`}</span>- більше /менше\n          </li>\n          <li>\n            <span className={s.Span}>{`a >= b`}</span> i{\" \"}\n            <span className={s.Span}>{`a <= b`}</span>- більше/менше або рівно{\" \"}\n          </li>\n          <li>\n            <span className={s.Span}>{`a == b`}</span> - рівність\n          </li>\n          <li>\n            <span className={s.Span}>{`a != b`}</span> - нерівність\n          </li>\n          <li>\n            <span className={s.Span}>{`a === b`}</span> - сувора рівність\n          </li>\n          <li>\n            <span className={s.Span}>{`a !== b`}</span> - сувора нерівність\n          </li>\n        </ul>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n             const x = 5;\n             const y = 10;\n             const z = 5;\n             \n             console.log(\"x > y:\", x > y); // false\n             console.log(\"x < y:\", x < y); // true\n             console.log(\"x < z:\", x < z); // false\n             console.log(\"x <= z:\", x <= z); // true\n             console.log(\"x === y:\", x === y); // false\n             console.log(\"x === z:\", x === z); // true\n             console.log(\"x !== y:\", x !== y); // true\n             console.log(\"x !== z:\", x !== z); // false\n                `}\n        </SyntaxHighlighter>\n        <h3>Оператори рівності</h3>\n        <p>\n          «Нестрогі» оператори рівності\n          <span className={s.Span}>==</span> і{\" \"}\n          <span className={s.Span}>!=</span> виконують перетворення типів\n          порівнюваних значень до числа, що може призвести до помилок, особливо\n          у початківців.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n             // ❌ Погано, виконується приведення типів\n             console.log(5 == \"5\"); // true\n             console.log(5 != \"5\"); // false\n             console.log(1 == true); // true\n             console.log(1 != true); // false\n                `}\n        </SyntaxHighlighter>\n        <p>\n          На наступній ілюстрації показано таблицю порівняння значень,\n          використовуючи оператори нестрогої рівності.\n        </p>\n        <img src={operatorTable1} alt=\"\" />\n        <p>\n          Тому для перевірки рівності або нерівності двох значень\n          використовуються тільки оператори <span className={s.Span}>===</span>{\" \"}\n          (сувора рівність) та <span className={s.Span}>!==</span> (сувора\n          нерівність), які не виконують наведення типів операндів.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n             // ✅ Добре, приведення типів не виконується\n             console.log(5 === \"5\"); // false\n             console.log(5 === 5); // true\n             console.log(5 !== \"5\"); // true\n             console.log(5 !== 5); // false\n             console.log(1 === true); // false\n             console.log(1 !== true); // true\n                `}\n        </SyntaxHighlighter>\n        <p>\n          У такому разі все дорівнює лиш собі. Перед оцінкою нічого не\n          перетворюється.\n        </p>\n        <img src={operatorTable2} alt=\"\" />\n\n        <h1 id=\"section-7\">Числа</h1>\n        <p>\n          Всі числа JavaScript, як цілі так і дробові, мають тип{\" \"}\n          <span className={s.Span}>Number</span> і записувати їх можна не тільки\n          в десятковій системі числення.\n        </p>\n        <h3>Приведення до числа</h3>\n        <p>\n          Більшість арифметичних операцій та математичних функцій перетворять\n          значення на число автоматично. Для того щоб зробити це явно,\n          використовуйте функцію <span className={s.Span}>Number(val)</span>,\n          передаючи їй у <span className={s.Span}>val</span> те, що треба\n          привести до числа.\n        </p>\n        <p>\n          Якщо значення не може призвести до числа, результатом буде спеціальне\n          числове значення <span className={s.Span}>NaN (Not a Number)</span>.\n          Аналогічним чином відбувається перетворення та інших математичних\n          операторах і функціях.\n        </p>\n\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n             const valueA = \"5\";\n             console.log(Number(valueA)); // 5\n             console.log(typeof Number(valueA)); // \"number\"\n             \n             const valueB = \"random string\";\n             console.log(Number(valueB)); // NaN\n             console.log(typeof Number(valueB)); // \"number\"\n                `}\n        </SyntaxHighlighter>\n        <h3>\n          Методи та <span className={s.Span}>Number.parseInt()</span>{\" \"}\n          <span className={s.Span}>Number.parseFloat()</span>\n        </h3>\n        <p>\n          Перетворюють рядок символ за символом, доки це можливо. У разі\n          виникнення помилки повертається число, яке вийшло.\n        </p>\n        <p>\n          Метод <span className={s.Span}>Number.parseInt()</span> парсить з\n          рядка ціле число.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n           console.log(Number.parseInt(\"5px\")); // 5\n           console.log(Number.parseInt(\"12qwe74\")); // 12\n           console.log(Number.parseInt(\"12.46qwe79\")); // 12\n           console.log(Number.parseInt(\"qweqwe\")); // NaN\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Метод <span className={s.Span}>Number.parseFloat()</span> парсить з\n          рядка ціле число.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n           console.log(Number.parseFloat(\"5px\")); // 5\n           console.log(Number.parseFloat(\"12qwe74\")); // 12\n           console.log(Number.parseFloat(\"12.46qwe79\")); // 12.46\n           console.log(Number.parseFloat(\"qweqwe\")); // NaN\n                `}\n        </SyntaxHighlighter>\n        <h3>Перевірка на число</h3>\n        <p>\n          Для перевірки на число можна використовувати метод{\" \"}\n          <span className={s.Span}>Number.isNaN(val)</span>. Він перевіряє, чи\n          вказане значення <span className={s.Span}>NaN</span> чи ні. Метод\n          відповідає питанням \"Це Not A Number?\" і повертає:\n        </p>\n        <ul>\n          <li>\n            <span className={s.Span}>true</span>- якщо значення{\" \"}\n            <span className={s.Span}>val</span> це{\" \"}\n            <span className={s.Span}>NaN</span>\n          </li>\n          <li>\n            <span className={s.Span}>false</span>- якщо значення{\" \"}\n            <span className={s.Span}>val</span> це не\n            <span className={s.Span}>NaN</span>\n          </li>\n        </ul>\n        <p>\n          Для всіх значень <span className={s.Span}>val</span> крім{\" \"}\n          <span className={s.Span}>NaN</span> при передачі в{\" \"}\n          <span className={s.Span}>Number.isNaN(val)</span> поверне{\" \"}\n          <span className={s.Span}>false</span>. Цей метод не робить спробу\n          перетворити <span className={s.Span}>val</span> до числа, а просто\n          виконує перевірку на <span className={s.Span}>NaN</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n           const validNumber = Number(\"51\"); // 51\n           console.log(Number.isNaN(validNumber)); // false\n           \n           const invalidNumber = Number(\"qweqwe\"); // NaN\n           console.log(Number.isNaN(invalidNumber)); // true\n                `}\n        </SyntaxHighlighter>\n        <h3>Додавання чисел з плаваючою крапкою</h3>\n        <p>\n          При додаванні не цілих чисел у JavaScript та інших мовах\n          програмування, є особливість. Якщо коротко, то{\" \"}\n          <span className={s.Span}>0.1 + 0.2</span> не одно{\" \"}\n          <span className={s.Span}>0.3</span>, результат додавання більше ніж{\" \"}\n          <span className={s.Span}>0.3</span>. Все від того, що машина рахує в\n          двійковій системі.\n        </p>\n        <p>\n          Число <span className={s.Span}>0.1</span> в двійковій системі числення\n          - це нескінченний дріб, тому що одиниця на десять у двійковій системі\n          не ділиться. Двійкове значення нескінченних дробів зберігається лише\n          певного знака, тому виникає неточність. При додаванні{\" \"}\n          <span className={s.Span}>0.1</span> і{\" \"}\n          <span className={s.Span}>0.2</span>, дві неточності складаються,\n          виходить незначна, але все ж таки помилка в обчисленнях.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          console.log(0.1 + 0.2 === 0.3); // false\n          console.log(0.1 + 0.2); // 0.30000000000000004\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Звичайно, це не означає, що точні обчислення таких чисел неможливі. Є\n          кілька методів вирішення цієї проблеми.\n        </p>\n        <p>\n          Можна зробити їх цілими, помноживши N, скласти, а потім результат\n          розділити також на N.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          console.log(0.17 + 0.24); // 0.41000000000000003\n          console.log((0.17 * 100 + 0.24 * 100) / 100); // 0.41\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Ще один спосіб - скласти, а результат відсікти до певного знака після\n          коми за допомогою методу <span className={s.Span}>toFixed()</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          console.log(0.17 + 0.24); // 0.41000000000000003\n          console.log((0.17 + 0.24).toFixed(2)); // 0.41\n                `}\n        </SyntaxHighlighter>\n\n        <h3>\n          Клас <span className={s.Span}>Math</span>\n        </h3>\n        <p>\n          Один із вбудованих класів, який надає набір методів для роботи з\n          числами. Знання всіх методів напам'ять не потрібно лише деяких,\n          найбільш корисних.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n        // Math.floor(num) - возвращает наибольшее целое число,\n        // меньшее, либо равное указанному\n        console.log(Math.floor(1.7)); // 1\n        \n        // Math.ceil(num) - возвращает наименьшее целое число,\n        // большее, либо равное указанному числу.\n        console.log(Math.ceil(1.2)); // 2\n        \n        // Math.round(num) - возвращает значение числа,\n        // округлённое до ближайшего целого\n        console.log(Math.round(1.2)); // 1\n        console.log(Math.round(1.5)); // 2\n        \n        // Math.max(num1, num2, ...) - возвращает наибольшее число из набора\n        console.log(Math.max(20, 10, 50, 40)); // 50\n        \n        // Math.min(num1, num2, ...) - возвращает наименьшее число из набора\n        console.log(Math.min(20, 10, 50, 40)); // 10\n        \n        // Math.pow(base, exponent) - возведение в степень\n        console.log(Math.pow(2, 4)); // 16\n        \n        // Math.random() - возвращает псевдослучайное число в диапазоне [0, 1)\n        console.log(Math.random()); // случайное число между 0 и 1\n        console.log(Math.random() * (10 - 1) + 1); // псевдослучайное число от 1 до 10\n                `}\n        </SyntaxHighlighter>\n        <h1 id=\"section-8\">Рядки</h1>\n        <p>\n          <span className={s.Span}>Рядок</span> - це індексований набір із нуля\n          або більше символів, укладених у одинарні або подвійні лапки.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n       const username = \"Olga\";\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Важливо пам'ятати, що індексація елементів рядка починається з нуля.\n          Наприклад у рядку <span className={s.Span}>\"JavaScript\"</span> літера{\" \"}\n          <span className={s.Span}>\"J\"</span> стоїть на позиції з індексом{\" \"}\n          <span className={s.Span}>0</span>, а{\" \"}\n          <span className={s.Span}>\"t\"</span> йде під індексом{\" \"}\n          <span className={s.Span}>9</span>.\n        </p>\n        <img className={s.stringImg} src={string} alt=\"\" />\n        <p>\n          Вміст рядка не можна змінити, лише прочитати. Тобто не можна взяти\n          якийсь символ і замінити його, як тільки рядок створено - він такий\n          назавжди. Можна лише створити цілком новий рядок і присвоїти змінну\n          замість старої.\n        </p>\n        <h3>Конкатенація рядків</h3>\n        <p>\n          Якщо застосувати оператор <span className={s.Span}>+</span> до рядка\n          та іншого типу даних, результатом операції «складання» буде рядок. Ця\n          операція називається конкатенація, або складання рядків.\n        </p>\n        <p>\n          Під час конкатенації будь-який тип даних приводиться до рядка і\n          зшивається з рядком, але є особливість - послідовність запису\n          операндів.\n        </p>\n        <p>\n          Послідовність операцій має значення, перетворення типів відбувається\n          лише на момент операції складання з рядком, доти діють звичні правила\n          математики.\n        </p>\n\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n       const message = \"Mango \" + \"is\" + \" happy\";\n       console.log(message); // Mango is happy\n                `}\n        </SyntaxHighlighter>\n\n        <p>Подивимося різний порядок операндов.</p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n      console.log(1 + \"2\"); // \"12\"\n      console.log(1 + \"2\" + 4); // \"124\"\n      console.log(1 + 2 + \"4\"); // \"34\"\n                `}\n        </SyntaxHighlighter>\n        <p>\n          В останньому прикладі відбулася математична операція додавання для\n          перших двох чисел <span className={s.Span}>1</span> і{\" \"}\n          <span className={s.Span}>2</span>, після чого число{\" \"}\n          <span className={s.Span}>3</span> було перетворено на рядок{\" \"}\n          <span className={s.Span}>\"3\"</span> і поєднано з рядком{\" \"}\n          <span className={s.Span}>\"4\"</span>.\n        </p>\n        <h3>Шаблонні рядки</h3>\n        <p>\n          Шаблонні рядки це альтернатива конкатенації з зручнішим синтаксисом.\n          Шаблонний рядок укладено у зворотні (косі) лапки замість подвійних або\n          одинарних і може містити місцезаповнювачі, які позначаються знаком\n          долара та фігурними дужками -{\" \"}\n          <span className={s.Span}>${`выражение`}</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n//Використовуючи змінні, необхідно скласти рядок з підставленими значеннями.\nconst guestName = \"Манго\";\nconst roomNumber = 207;\nconst greeting =\n  \"Welcome \" + guestName + \", your room number is \" + roomNumber + \"!\";\nconsole.log(greeting); // \"Welcome Mango, your room number is 207!\"                `}\n        </SyntaxHighlighter>\n        <p>\n          Складати рядки з значеннями, що підставляються, використовуючи\n          конкатенацію дуже незручно. На допомогу приходять шаблонні рядки та\n          інтерполяція.\n        </p>\n        <img src={code1} alt=\"\" />\n        <h3>Властивості та методи рядків</h3>\n        <p>\n          Кожний рядок має вбудовані властивості та методи, розглянемо деякі з\n          них.\n        </p>\n        <h4>\n          Властивість <span className={s.Span}>length</span>\n        </h4>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n                const message = \"Welcome to Bahamas!\";\n                console.log(message.length); // 19\n                console.log(\"There is nothing impossible to him who will try\".length); // 47\n\n         `}\n        </SyntaxHighlighter>\n        <h4>\n          Методи <span className={s.Span}>toLowerCase()</span>{\" \"}\n          <span className={s.Span}>toUpperCase()</span>\n        </h4>\n        <p>\n          Повертають новий рядок у відповідному регістрі, не змінюючи\n          оригінальний рядок.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n                const message = \"Welcome to Bahamas!\";\n                console.log(message.toLowerCase()); // \"welcome to bahamas!\"\n                console.log(message.toUpperCase()); // \"WELCOME TO BAHAMAS!\"\n                console.log(message); // \"Welcome to Bahamas!\"\n\n         `}\n        </SyntaxHighlighter>\n        <p>\n          Бувають ситуації коли всі символи в рядку необхідно перетворити на\n          один регістр, верхній або нижній. Наприклад, при пошуку за ключовим\n          словом, коли користувач вводить рядок{\" \"}\n          <span className={s.Span}>'saMsUng'</span>, а порівняти його треба з\n          рядком <span className={s.Span}>'samsung'</span> або{\" \"}\n          <span className={s.Span}>'SAMSUNG'</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n               console.log(\"saMsUng\" === \"samsung\"); // false\n               console.log(\"saMsUng\" === \"SAMSUNG\"); // false\n\n            `}\n        </SyntaxHighlighter>\n        <p>\n          Щоб не вимагати абсолютно точного введення, можна зробити\n          «нормалізацію» введеного користувачем рядка, тобто перетворити всі\n          його символи у верхній або нижній регістр. Методи рядка{\" \"}\n          <span className={s.Span}>toLowerCase()</span> та{\" \"}\n          <span className={s.Span}>toUpperCase()</span> повернуть новий рядок у\n          відповідному регістрі, не змінюючи оригінальний.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n               const BRAND_NAME = \"SAMSUNG\";\n               const userInput = \"saMsUng\";\n               const normalizedToUpperCaseInput = userInput.toUpperCase();\n               \n               console.log(userInput); // 'saMsUng'\n               console.log(userInput === BRAND_NAME); // false\n               console.log(normalizedToUpperCaseInput); // 'SAMSUNG'\n               console.log(normalizedToUpperCaseInput === BRAND_NAME); // true\n\n            `}\n        </SyntaxHighlighter>\n\n        <h4>\n          Метод <span className={s.Span}>indexOf()</span>\n        </h4>\n        <p>\n          Повертає позицію (індекс) на якій знаходиться перший збіг підрядка або{\" \"}\n          <span className={s.Span}>-1</span> якщо нічого не знайдено.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n               const message = \"Welcome to Bahamas!\";\n               console.log(message.indexOf(\"to\")); // 8\n               console.log(message.indexOf(\"hello\")); // -1\n\n            `}\n        </SyntaxHighlighter>\n        <h4>\n          Метод <span className={s.Span}>includes()</span>\n        </h4>\n        <p>\n          Перевіряє чи входить підрядок у рядок, повертає буль -{\" \"}\n          <span className={s.Span}>true</span> якщо входить і{\" \"}\n          <span className={s.Span}>false</span> в іншому випадку. Регістр\n          символів у рядку та підрядку має значення, тому що наприклад буква{\" \"}\n          <span className={s.Span}>\"a\"</span> не дорівнює букві{\" \"}\n          <span className={s.Span}>\"А\"</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n               const productName = \"Ремонтний дроїд\";\n\n               console.log(productName.includes(\"н\")); // true\n               console.log(productName.includes(\"Н\")); // false\n               console.log(productName.includes(\"дроїд\")); // true\n               console.log(productName.includes(\"Дроїд\")); // false\n               console.log(productName.includes(\"Ремонтний\")); // true\n               console.log(productName.includes(\"ремонтний\")); // false\n\n            `}\n        </SyntaxHighlighter>\n        <div className={s.interestBox}>\n          <div className={s.interestHeader}>\n            <svg className={s.textIcon}>\n              <use href={sprite + \"#target\"}></use>\n            </svg>\n            <h5>ЦІКАВО</h5>\n          </div>\n          <p>Усі методи рядків чутливі до регістру.</p>\n        </div>\n        <h5>\n          Метод <span className={s.Span}>endsWith()</span>\n        </h5>\n        <p>\n          Дозволяє визначити, чи рядок закінчується символами (підрядком)\n          зазначеними в дужках, повертаючи <span className={s.Span}>true</span>{\" \"}\n          або <span className={s.Span}>false</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n               const jsFileName = \"script.js\";\n               console.log(jsFileName.endsWith(\".js\")); // true\n               \n               const cssFileName = \"styles.css\";\n               console.log(cssFileName.endsWith(\".js\")); // false\n\n            `}\n        </SyntaxHighlighter>\n        <h5>\n          Методи <span className={s.Span}>replace()</span> та{\" \"}\n          <span className={s.Span}>replaceAll()</span>\n        </h5>\n        <p>\n          Повертають новий рядок, в якому перші (replace) або всі збіги\n          (replaceAll) підрядки замінені на вказане значення.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n              const jsFileName = \"script.js\";\n              const minifiedJsFileName = jsFileName.replace(\".js\", \".min.js\");\n              console.log(minifiedJsFileName); // \"script.min.js\"\n              \n              const cssFileNames = \"styles.css, about.css, portfolio.css\";\n              const minifiedCssFileNames = cssFileNames.replaceAll(\".css\", \".min.css\");\n              console.log(minifiedCssFileNames); // \"styles.min.css, about.min.css, portfolio.min.css\"\n\n            `}\n        </SyntaxHighlighter>\n        <h5>\n          Метод <span className={s.Span}>slice()</span>\n        </h5>\n        <p>\n          Метод рядків{\" \"}\n          <span className={s.Span}>slice(startIndex, endIndex)</span>{\" \"}\n          використовується для створення копії частини чи всього рядка. Він\n          робить копію елементів рядка від{\" \"}\n          <span className={s.Span}>startIndex</span> і до, але не включаючи{\" \"}\n          <span className={s.Span}>endIndex</span> та повертає новий рядок, не\n          змінюючи оригінал.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n              const productName = \"Repair droid\";\n              console.log(productName.slice(0, 4)); // \"Repa\"\n              console.log(productName.slice(3, 9)); // \"air dr\"\n              console.log(productName.slice(0, productName.length)); // \"Repair droid\"\n              console.log(productName.slice(7, productName.length)); // \"droid\"\n\n            `}\n        </SyntaxHighlighter>\n        <h1 id=\"section-9\">Логічні оператори</h1>\n        <p>\n          Логічні оператори використовуються для перевірки умов з множинними\n          виразами, наприклад, в операціях порівняння.\n        </p>\n        <h3>Приведення типів </h3>\n        <p>\n          У логічних операціях здійснюється приведення типів операндів до{\" \"}\n          <span className={s.Span}>true</span> або{\" \"}\n          <span className={s.Span}>false</span>. Приведення відбувається якщо\n          код виявлено логічний оператор.\n        </p>\n        <p>\n          <strong>Truthy</strong> і <strong>Falsy</strong> - терміни, які\n          використовуються для тих значень, які, в логічній операції, наводяться\n          до <span className={s.Span}>true</span> або{\" \"}\n          <span className={s.Span}>false</span>, хоча спочатку не були булями.\n        </p>\n        <div className={s.interestBox}>\n          <div className={s.interestHeader}>\n            <svg className={s.textIcon}>\n              <use href={sprite + \"#target\"}></use>\n            </svg>\n            <h5>ЦІКАВО</h5>\n          </div>\n          <p>\n            Запам'ятайте 6 помилкових (falsy) значень, що приводяться до{\" \"}\n            <span className={s.Span}>SyntaxHighlighterfalse</span> логічного\n            перетворення: <span className={s.Span}>0</span>,{\" \"}\n            <span className={s.Span}>NaN</span>,{\" \"}\n            <span className={s.Span}>null</span>,{\" \"}\n            <span className={s.Span}>undefined</span>,{\" \"}\n            <span className={s.Span}>порожній рядок</span> і{\" \"}\n            <span className={s.Span}>false</span>. Абсолютно все інше наводиться\n            до true.\n          </p>\n        </div>\n        <h3>Логічні оператори</h3>\n        <p>\n          Є три логічні оператори, які використовуються для перевірки виконання\n          множинних виразів.\n        </p>\n        <img src={booleanOperators} alt=\"\" />\n        <h3>Логічне \"І\"</h3>\n        <p>\n          Оператор <span className={s.Span}>&&</span> приводить усі операнди до\n          булю та повертає значення одного з них. Лівий операнд якщо його можна\n          призвести до <span className={s.Span}>false</span>, і правий в інших\n          випадках.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n              вираз && вираз\n            `}\n        </SyntaxHighlighter>\n        <p>\n          У наступному прикладі обидві умови повернуть{\" \"}\n          <span className={s.Span}>true</span>, тому результатом всього виразу\n          буде <span className={s.Span}>true</span>- повернеться значення\n          правого операнда.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n              const age = 20;\n              console.log(age > 10 && age < 30); // true && true -> true\n            `}\n        </SyntaxHighlighter>\n        <p>\n          Тобто логічне «І» замикається на брехні і повертає те, на чому\n          запнулося або останній операнд.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n              console.log(1 && 5); // true && true -> 5\n              console.log(5 && 1); // true && true -> 1\n              console.log(0 && 2); // false && true -> 0\n              console.log(2 && 0); // true && false -> 0\n              console.log(\"\" && \"Mango\"); // false && true -> \"\"\n              console.log(\"Mango\" && \"\"); // true && false -> \"\"\n              console.log(\"Mango\" && \"Poly\"); // true && true -> \"Poly\"\n              console.log(\"Poly\" && \"Mango\"); // true && true -> \"Mango\"\n            `}\n        </SyntaxHighlighter>\n        <div className={s.interestBox}>\n          <div className={s.interestHeader}>\n            <svg className={s.textIcon}>\n              <use href={sprite + \"#target\"}></use>\n            </svg>\n            <h5>ЦІКАВО</h5>\n          </div>\n          <p>\n            При виконанні логічного «І», правий операнд може не обчислюватися,\n            якщо лівий був приведений до <span className={s.Span}>false</span>.\n          </p>\n        </div>\n        <h3>Логічне \"АБО\"</h3>\n        <p>\n          Оператор <span className={s.Span}>||</span> приводить усі операнди до\n          булю та повертає значення одного з них. Лівий операнд якщо його можна\n          призвести до <span className={s.Span}>true</span>, і правий в інших\n          випадках.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>{`\n                const age = 5;\n                console.log(age < 10 || age > 30); // true || false -> true\n            \n            `}</SyntaxHighlighter>\n        <p>\n          Тут результатом теж буде <span className={s.Span}>true</span>,\n          оскільки хоча б один з операндів, у цьому випадку правий, був\n          приведений до <span className={s.Span}>true</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>{`\n                const age = 20;\n                console.log(age < 10 || age > 30); // false || false -> false\n            \n            `}</SyntaxHighlighter>\n        <p>\n          Тобто логічне «АБО» замикається на правді і повертає те, на чому\n          запнулося або останній операнд.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>{`\n                console.log(true || false); // true\n                console.log(false || true); // true\n                console.log(true || true); // true\n                \n                console.log(3 || false); // 3\n                console.log(false || 3); // 3\n                console.log(3 || true); // 3\n                console.log(true || 3); // true\n            \n            `}</SyntaxHighlighter>\n        <div className={s.interestBox}>\n          <div className={s.interestHeader}>\n            <svg className={s.textIcon}>\n              <use href={sprite + \"#target\"}></use>\n            </svg>\n            <h5>ЦІКАВО</h5>\n          </div>\n          <p>\n            При виконанні логічного «АБО», правий операнд може не обчислюватися,\n            якщо лівий був приведений до <span className={s.Span}>true</span>.\n          </p>\n        </div>\n        <h3>Логічне \"НЕ\"</h3>\n        <p>\n          Всі оператори, які ми розглядали до цього, були{\" \"}\n          <strong>бінарними</strong> - що містять два операнди, лівий і правий.\n          Логічне «НЕ» це <strong>унарний</strong> оператор, який виконує\n          операцію над одним операндом праворуч.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>{`\n               !вираз\n            \n            `}</SyntaxHighlighter>\n        <p>\n          Оператор <span className={s.Span}>!</span> приводить операнд до булю,\n          якщо необхідно, а потім робить інверсію – замінює його на протилежний{\" \"}\n          <span className={s.Span}>{`true -> false`}</span> або{\" \"}\n          <span className={s.Span}>{`false -> true`}</span>.\n        </p>\n\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>{`\n               console.log(!true); // false\n               console.log(!false); // true\n               console.log(!3); // !3 -> !true -> false\n               console.log(!\"Mango\"); // !\"Mango\" -> !true -> false\n               console.log(!0); // !0 -> !false -> true\n               console.log(!\"\"); // !\"\" -> !false -> true\n               \n               const isOnline = true;\n               const isNotOnline = !isOnline; // !isOnline -> !true -> false\n            \n            `}</SyntaxHighlighter>\n      </div>\n    </div>\n  );\n};\n\nexport default M1L1;\n","/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/Header/Header.jsx",[],[],"/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/Lessons/Arrey.jsx",[],[],"/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/Lessons/Function.jsx",[],[],"/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/Lessons/Object.jsx",[],[],"/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/Lessons/SpreadRest.jsx",["104"],[],"import React from \"react\";\nimport { Prism as SyntaxHighlighter } from \"react-syntax-highlighter\";\nimport { materialDark } from \"react-syntax-highlighter/dist/esm/styles/prism\";\n\nimport s from \"./Lessons.module.css\";\nimport sprite from \"../../img/icomoon/sprite.svg\";\nimport Scrollspy from \"react-scrollspy\";\n\nconst SpreadRest = () => {\n  const codeStyle = materialDark;\n  return (\n    <div className={s.lessonsBox}>\n      <div className={s.breadNav}>\n        <Scrollspy\n          items={[\"branching\", \"section-2\", \"section-3\"]}\n          currentClassName=\"is-current\"\n        >\n          <div className={s.breadNavList}>\n            <li>\n              <a href=\"#spread\">Синтаксис spread та rest</a>\n            </li>\n            <li>\n              <a href=\"#desObject\">Деструктуризація об'єктів</a>\n            </li>\n            <li>\n              <a href=\"#desArray\">Деструктуризація масивів</a>\n            </li>\n            <li>\n              <a href=\"#patern\">Паттерн \"Об'єкт параметрів\"</a>\n            </li>\n          </div>\n        </Scrollspy>\n      </div>\n      <div className={s.article}>\n        <h1 id=\"spread\">Синтаксис spread та rest</h1>\n        <p>\n          У сучасному стандарті з'явився новий синтаксис для роботи з\n          сутностями, що ітеруються, такими як рядок, масив або об'єкт. Його\n          функціонал та назва залежить від місця застосування.\n        </p>\n        <h3>\n          <span className={s.Span}>spread</span> : передача аргументів{\" \"}\n        </h3>\n        <p>\n          Операція <span className={s.Span}>...(spread)</span> дозволяє\n          розпорошити колекцію елементів (масив, рядок чи об'єкт) на місце, де\n          очікується набір окремих значень. Звичайно є деякі обмеження,\n          наприклад, не можна розпорошити масив в об'єкт і навпаки.\n        </p>\n        <p>\n          Можна навести аналогію зі скринькою яблук. Поставивши ящик на підлогу,\n          не виймаючи з нього яблука, отримаємо аналог масиву значень. Якщо\n          висипати яблука із ящика на підлогу, відбудеться розпилення – набір\n          окремих значень.\n        </p>\n        <p>\n          Відмінність всього одна - JavaScript розпилення не змінює оригінальну\n          колекцію, тобто робиться копія кожного елемента. Після розпилення\n          залишиться ящик повний яблук і копія кожного яблука на підлозі.\n        </p>\n        <p>\n          Наприклад, метод <span className={s.Span}>Math.max(аргументи)</span>{\" \"}\n          шукає і повертає найбільший аргументів (чисел), тобто очікує не масив\n          значень, а довільна кількість аргументів.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const temps = [14, -4, 25, 8, 11];\n\n          // В консолі буде массив\n          console.log(temps);\n          // ❌ Так працювати не буде, тому що передаємо цілий масив\n          console.log(Math.max(temps)); // NaN\n\n          // В консолі буде набір окремих чисел\n          console.log(...temps);\n          // ✅ Розпорошуємо колекцію елементів, як окремі аргументи\n          console.log(Math.max(...temps)); // 25\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Тобто запис{\" \"}\n          <span className={s.Span}>Math.max(...[14, -4, 25, 8, 11])</span>,\n          після інтерпретації перетворюється на{\" \"}\n          <span className={s.Span}>Math.max(14, -4, 25, 8, 11)</span> -\n          синтаксис <span className={s.Span}>...</span> повертає розпакований\n          масив, тобто розпорошує його елементи як окремі аргументи.\n        </p>\n        <h3>\n          <span className={s.Span}>spread </span>: створення нового масиву\n        </h3>\n        <p>\n          Операція <span className={s.Span}>...(spread)</span> дозволяє створити\n          копію масиву або \"склеїти\" довільну кількість масивів в один новий.\n          Раніше для цього використовували методи{\" \"}\n          <span className={s.Span}>slice()</span>,{\" \"}\n          <span className={s.Span}>concat()</span> але операція розпилення\n          дозволяє зробити те ж саме в більш короткій формі.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const temps = [14, -4, 25, 8, 11];\n\n          // Це точна, але незалежна копія масиву temps\n          const copyOfTemps = [...temps];\n          console.log(copyOfTemps); // [14, -4, 25, 8, 11]  \n                `}\n        </SyntaxHighlighter>\n        <p>\n          У прикладі вище ми маємо ящик яблук{\" \"}\n          <span className={s.Span}>temps</span> і ми хочемо зробити його точну\n          копію. Беремо порожню скриньку і пересипаємо в неї яблука з вихідної\n          скриньки <span className={s.Span}>temps</span> - розпорошуємо її в\n          іншу колекцію. При цьому скринька{\" \"}\n          <span className={s.Span}>temps</span> не зміниться, в ній все ще\n          будуть яблука, а в новій скриньці – їх точні копії.\n        </p>\n        <p>\n          У наступному прикладі ми зсипаємо яблука з двох ящиків в одну нову.\n          Оригінальні ящики (масиви) не зміняться, а в новому будуть копії всіх\n          їх яблук (елементів). Порядок розпилення важливий – він впливає на\n          порядок елементів у новій колекції.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const first = { propA: 5, propB: 10 };\n          const second = { propC: 15 };\n          const third = { ...first, ...second };\n          console.log(third); // { propA: 5, propB: 10, propC: 15 }  \n                `}\n        </SyntaxHighlighter>\n        <p>\n          Порядок розпилення має значення. Імена властивостей об'єкта унікальні,\n          тому властивості об'єкта, що розпилюється, можуть перезаписати\n          значення вже існуючої властивості, якщо їх імена збігаються.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const first = { propA: 5, propB: 10, propC: 50 };\n          const second = { propC: 15, propD: 20 };\n\n          const third = { ...first, ...second };\n          console.log(third); // { propA: 5, propB: 10, propC: 15, propD: 20 }\n\n          const fourth = { ...second, ...first };\n          console.log(fourth); // { propA: 5, propB: 10, propC: 50, propD: 20 }  \n                `}\n        </SyntaxHighlighter>\n        <p>\n          Якби яблука в ящику мали наклейки з мітками, то в одному ящику не може\n          бути двох яблук з однаковими мітками. Тому при пересипанні другого\n          ящика, всі яблука, мітки яких збігатимуться з тими, що вже є в новому,\n          замінять ті, що вже є.\n        </p>\n        <p>\n          Під час розпилення можна додавати властивості довільного місця.\n          Головне пам'ятати про унікальність імені та про те, що його значення\n          може бути перезаписано.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const first = { propA: 5, propB: 10, propC: 50 };\n          const second = { propC: 15 };\n\n          const third = { propB: 20, ...first, ...second };\n          console.log(third); // { propA: 5, propB: 10, propC: 15 }\n\n          const fourth = { ...first, ...second, propB: 20 };\n          console.log(fourth); // { propA: 5, propB: 20, propC: 15 }\n\n          const fifth = { ...first, propB: 20, ...second };\n          console.log(fifth); // { propA: 5, propB: 20, propC: 15 }  \n                `}\n        </SyntaxHighlighter>\n        <h3>\n          <span className={s.Span}>rest</span> : збір усіх аргументів функції\n        </h3>\n        <p>\n          Операція <span className={s.Span}>...</span> (rest) дозволяє зібрати\n          групу незалежних елементів у нову колекцію. Синтаксично це близнюк\n          операції розпилення, але відрізнити їх просто - розпилення коли{\" \"}\n          <span className={s.Span}>...</span> знаходиться у{\" \"}\n          <strong>правій</strong> частині операції присвоєння, а збір це коли\n          <span className={s.Span}>...</span> знаходиться в її{\" \"}\n          <strong>лівій</strong> частині.\n        </p>\n        <p>\n          Повернімося до аналогії з яблуками. Якщо на підлозі лежать яблука і ми\n          маємо порожню скриньку, то операція{\" \"}\n          <span className={s.Span}>rest</span> дозволить «зібрати» яблука в\n          ящик. При цьому оригінальні яблука залишаться на підлозі, а у ящику\n          буде копія кожного яблука.\n        </p>\n        <p>\n          Одна з областей застосування операції{\" \"}\n          <span className={s.Span}>rest</span> це створення функцій, які можуть\n          приймати довільну кількість аргументів.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          // Як оголосити параметри функції так,\n          // щоб можна було передати будь-яку кількість аргументів?\n          function multiply() {\n            // ...\n          }\n\n          multiply(1, 2);\n          multiply(1, 2, 3);\n          multiply(1, 2, 3, 4);\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Якщо прибрати весь «синтаксичний шум» і подивитися на аргументи та\n          параметри функції, то аргументи знаходяться у правій частині операції\n          присвоювання, а параметри у лівій, тому що значення аргументів\n          надаються оголошеним параметрам. Отже, можна «збирати» всі аргументи\n          функції в один параметр використовуючи операцію{\" \"}\n          <span className={s.Span}>rest</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          function multiply(...args) {\n            console.log(args); // масив всіх аргументів\n          }\n\n          multiply(1, 2);\n          multiply(1, 2, 3);\n          multiply(1, 2, 3, 4);\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Ім'я параметра може бути довільним. Найчастіше його називають{\" \"}\n          <span className={s.Span}>args</span>,{\" \"}\n          <span className={s.Span}>restArgs</span> або{\" \"}\n          <span className={s.Span}>otherArgs</span>, скорочене від{\" \"}\n          <span className={s.Span}>arguments</span>.\n        </p>\n        <h3>\n          <span className={s.Span}>rest</span> : збір частини аргументів функції{\" \"}\n        </h3>\n        <p>\n          Операція <span className={s.Span}>...</span> (rest) також дозволяє\n          зібрати в масив лише частину аргументів, яка необхідна, оголосивши\n          параметри до «збору».\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          function multiply(firstNumber, secondNumber, ...otherArgs) {\n            console.log(firstNumber); // Значеня першого аргумента\n            console.log(secondNumber); // Значеня другого аргумента\n            console.log(otherArgs); // Масив інших аргументів\n          }\n\n          multiply(1, 2);\n          multiply(1, 2, 3);\n          multiply(1, 2, 3, 4);\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Всі агументи, для яких будуть оголошені параметри, передадуть їм свої\n          значення, решта аргументів буде поміщена в масив. Операція{\" \"}\n          <span className={s.Span}>rest</span> збирає всі аргументи, що\n          залишилися, і тому повинна йти останньою в підписі функції, інакше\n          буде помилка.\n        </p>\n        <h1 id=\"desObject\">Деструктуризація об'єктів</h1>\n        <p>\n          При розробці програм дані приходять, як правило, у вигляді масивів та\n          об'єктів, значення яких необхідно записати до локальних змінних. Для\n          того, щоб робити це максимально просто, у сучасному стандарті є\n          синтаксис деструктуруючого присвоєння.\n        </p>\n        <h3>Деструктуризація об'єктів</h3>\n        <p>\n          Складні дані завжди представлені об'єктом. Численні звернення до\n          властивостей об'єкта візуально забруднюють код.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const book = {\n            title: \"The Last Kingdom\",\n            author: \"Bernard Cornwell\",\n            genres: [\"historical prose\", \"adventure\"],\n            isPublic: true,\n            rating: 8.38,\n          };\n\n          const accessType = book.isPublic ? \"публичном\" : \"закрытом\";\n          const message = \\`Книга $\\{book.title} автора $\\{book.author} з рейтингом $\\{book.rating} знаходится в $\\{accessType} доступі.\\`;\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Деструктуризація дозволяє «розпакувати» значення властивостей об'єкта\n          локальні змінні. Це робить код у місці їх використання менш «шумним».\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const book = {\n            title: \"The Last Kingdom\",\n            author: \"Bernard Cornwell\",\n            genres: [\"historical prose\", \"adventure\"],\n            isPublic: true,\n            rating: 8.38,\n          };\n\n          // Деструктуризуємо\n          const { title, author, isPublic, rating, coverImage } = book;\n          console.log(coverImage); // undefined\n\n          const accessType = isPublic ? \"публічному\" : \"закритому\";\n          const message = \\`Книга $\\{title} автора $\\{author} з рейтингом $\\{rating} знаходиться в $\\{accessType} доступі.\\`;\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Деструктуризація завжди знаходиться у лівій частині операції\n          присвоєння. Змінним усередині фігурних дужок надаються значення\n          властивостей об'єкта. Якщо ім'я змінної та ім'я властивості\n          збігаються, відбувається привласнення, інакше їй буде присвоєно\n          <span className={s.Span}>undefined</span>. Порядок оголошення змінних\n          у фігурних дужках не є важливим.\n        </p>\n        <h3>Значення по дефолту</h3>\n        <p>\n          Для того щоб уникнути присвоєння{\" \"}\n          <span className={s.Span}>undefined</span> при деструктуризації\n          неіснуючих властивостей об'єкта, можна задати змінним значення за\n          замовчуванням, які будуть присвоєні лише у випадку, коли об'єкт не має\n          властивості з таким ім'ям.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const book = {\n            title: \"The Last Kingdom\",\n            author: \"Bernard Cornwell\",\n          };\n\n          // Додаємо зображення обкладинки, якщо її немає в обєкті кники\n          const {\n            title,\n            coverImage = \"https://via.placeholder.com/640/480\",\n            author,\n          } = book;\n\n          console.log(title); // The Last Kingdom\n          console.log(author); // Bernard Cornwell\n          console.log(coverImage); // https://via.placeholder.com/640/480\n                `}\n        </SyntaxHighlighter>\n        <h3>Зміна імені змінної</h3>\n        <p>\n          При деструктуризації можна змінити ім'я змінної, в яку розпаковується\n          значення властивості. Спочатку пишемо ім'я властивості з якого хочемо\n          отримати значення, після чого ставимо двокрапку і пишемо ім'я змінної,\n          в яку необхідно помістити значення цієї властивості.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const firstBook = {\n            title: \"The Last Kingdom\",\n            coverImage:\n              \"https://images-na.ssl-images-amazon.com/images/I/51b5YG6Y1rL.jpg\",\n          };\n\n          const {\n            title: firstTitle,\n            coverImage: firstCoverImage = \"https://via.placeholder.com/640/480\",\n          } = firstBook;\n\n          console.log(firstTitle); // The Last Kingdom\n          console.log(firstCoverImage); // https://images-na.ssl-images-amazon.com/images/I/51b5YG6Y1rL.jpg\n\n          const secondBook = {\n            title: \"Сон смішної людини\",\n          };\n\n          const {\n            title: secondTitle,\n            coverImage: secondCoverImage = \"https://via.placeholder.com/640/480\",\n          } = secondBook;\n\n          console.log(secondTitle); // Сон смішної людини\n          console.log(secondCoverImage); // https://via.placeholder.com/640/480  \n                `}\n        </SyntaxHighlighter>\n        <p>\n          Такий запис читається як «Створити змінну{\" \"}\n          <span className={s.Span}>firstTitle</span>, у якому помістити значення\n          якості <span className={s.Span}>title</span> з об'єкта\n          <span className={s.Span}>firstBook</span>» тощо.\n        </p>\n        <h3>Деструктуризація в циклах</h3>\n        <p>\n          При переборі масиву об'єктів циклом{\" \"}\n          <span className={s.Span}>for...of</span> виходять численні звернення\n          до властивостей об'єкта.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            const books = [\n            {\n              title: \"The Last Kingdom\",\n              author: \"Bernard Cornwell\",\n              rating: 8.38,\n            },\n            {\n              title: \"На березі спокійних вод\",\n              author: \"Роберт Шеклі\",\n              rating: 8.51,\n            },\n          ];\n\n          for (const book of books) {\n            console.log(book.title);\n            console.log(book.author);\n            console.log(book.rating);\n          }\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Щоб скоротити кількість повторень можна деструктуризувати властивості\n          об'єкта в локальні змінні в тілі циклу.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          for (const book of books) {\n            const { title, author, rating } = book;\n\n            console.log(title);\n            console.log(author);\n            console.log(rating);\n          }  \n                `}\n        </SyntaxHighlighter>\n        <p>\n          Якщо в об'єкті небагато властивостей, деструктуризацію можна виконати\n          прямо на місці оголошення змінної <span className={s.Span}>book</span>\n          .\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            for (const { title, author, rating } of books) {\n              console.log(title);\n              console.log(author);\n              console.log(rating);\n            }\n                `}\n        </SyntaxHighlighter>\n        <h3>Глибока деструктуризація</h3>\n        <p>\n          Для деструктуризації властивостей вкладених об'єктів використовуються\n          самі принципи, як у трьох попередніх вправах.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const user = {\n            name: \"Jacques Gluke\",\n            tag: \"jgluke\",\n            stats: {\n              followers: 5603,\n              views: 4827,\n              likes: 1308,\n            },\n          };\n\n          const {\n            name,\n            tag,\n            stats: { followers, views: userViews, likes: userLikes = 0 },\n          } = user;\n\n          console.log(name); // Jacques Gluke\n          console.log(tag); // jgluke\n          console.log(followers); // 5603\n          console.log(userViews); // 4827\n          console.log(userLikes); // 1308  \n                `}\n        </SyntaxHighlighter>\n        <h1 id=\"desArray\">Деструктуризація масивів</h1>\n        <p>\n          Деструктуризуєче присвоєння можна використовувати і для масивів, але з\n          деякими особливостями.\n        </p>\n        <ul>\n          <li>\n            Замість фігурних дужок <span className={s.Span}>{\"{}\"}</span>{\" \"}\n            використовуються квадратні <span className={s.Span}>{\"[]\"}</span>.\n          </li>\n          <li>\n            Змінним, вказаним у квадратних дужках{\" \"}\n            <span className={s.Span}>{\"[]\"}</span> будуть послідовно\n            присвоюватися значення елементів масиву.\n          </li>\n        </ul>\n        <p>\n          Наприклад, є масив кольорів з якого потрібно окремі змінні отримати\n          значення кожної складової кольору.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const rgb = [200, 255, 100];\n          const [red, green, blue] = rgb;\n\n          console.log(\\`R:$\\{red},G:$\\{green},B:$\\{blue}\\`); // \"R:200,G:255,B:100\"  \n                `}\n        </SyntaxHighlighter>\n        <p>\n          Після ключового слова <span className={s.Span}>const</span> або{\" \"}\n          <span className={s.Span}>let</span> ставимо, що відкриває і закриває\n          квадратні дужки, як при оголошенні масиву. Усередині дужок, через\n          кому, вказуємо імена змінних, які будуть поміщені значення масиву.\n        </p>\n        <p>\n          В результаті такого запису будуть створені 3 змінні і в них будуть\n          розміщені елементи в нумерованому порядку - від 0 до кінця масиву.\n        </p>\n        <p>\n          При деструктуризації масивів значення змінної може бути присвоєно\n          після її оголошення. Насправді це використовується рідко.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const rgb = [200, 255, 100];\n          let red, green, blue;\n\n          [red, green, blue] = rgb;\n\n          console.log(\\`R:$\\{red},G:$\\{green},B:$\\{blue}\\`); // \"R:200,G:255,B:100\"  \n                `}\n        </SyntaxHighlighter>\n        <p>\n          Якщо змінних більше елементів масиву, їм буде присвоєно undefined,\n          тому можна вказувати значення за замовчуванням.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const rgb = [200, 100, 255];\n\n          const [red, green, blue, alfa = 0.3] = rgb;\n\n          console.log(\\`R:$\\{red},G:$\\{green},B:$\\{blue},Alfa:$\\{alfa}\\`); // \"R:200,G:100,B:255,Alfa:0.3\"  \n                `}\n        </SyntaxHighlighter>\n        <p>\n          Іноді з масиву необхідно деструктуризувати лише перші{\" \"}\n          <span className={s.Span}>N</span> елементи, а інші зберегти в одну\n          змінну у вигляді масиву. При деструкції масиву можна розпакувати і\n          привласнити частину елементів масиву змінної, використовуючи операцію{\" \"}\n          <span className={s.Span}>...</span>(rest).\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const rgb = [200, 255, 100];\n\n          const [red, ...colors] = rgb;\n\n          console.log(red); // \"200\"\n          console.log(colors); // [255, 100]  \n                `}\n        </SyntaxHighlighter>\n        <p>\n          Елементи можна пропускати. Допустимо, з масиву{\" \"}\n          <span className={s.Span}>rgb</span> необхідно взяти тільки останнє\n          значення. Насправді ця можливість використовується рідко.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const rgb = [200, 100, 255];\n\n          const [, , blue] = rgb;\n\n          console.log(\\`Blue: $\\{blue}\\`); // \"Blue: 255\"  \n                `}\n        </SyntaxHighlighter>\n        <h1 id=\"patern\">Паттерн \"Об'єкт параметрів\"</h1>\n        <p>\n          Якщо функція приймає більше двох-трьох аргументів, дуже просто\n          заплутатися в якій послідовності, що передавати. В результаті виходить\n          дуже неочевидний код у місці її виклику.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            function doStuffWithBook(title, numberOfPages, downloads, rating, public) {\n              // Робимо щось з патернами\n              console.log(title);\n              console.log(numberOfPages);\n              // і так далі\n            }\n\n            // ❌ Що таке 736? Що таке 10283? Що таке true?\n            doStuffWithBook(\"The Last Kingdom\", 736, 10283, 8.38, true);\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Паттерн \"Об'єкт параметрів\" допомагає вирішити цю проблему, замінюючи\n          набір параметрів лише одним - об'єктом з іменованими властивостями.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            function doStuffWithBook(book) {\n            // Робимо щось з властивостями обʼєкта\n            console.log(book.title);\n            console.log(book.numberOfPages);\n            // і так далі\n          }\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Тоді під час її виклику передаємо один об'єкт із необхідними\n          властивостями.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          // ✅ Все зрозуміло \n          doStuffWithBook({\n            title: \"The Last Kingdom\",\n            numberOfPages: 736,\n            downloads: 10283,\n           rating: 8.38,\n            isPublic: true,\n          });  \n                `}\n        </SyntaxHighlighter>\n        <p>\n          Ще один плюс у тому, що можна деструктурувати об'єкт у параметрі{\" \"}\n          <span className={s.Span}>book</span>. Це можна зробити у тілі функції.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          function doStuffWithBook(book) {\n            const { title, numberOfPages, downloads, rating, isPublic } = book;\n            console.log(title);\n            console.log(numberOfPages);\n            // і так далі\n          }  \n                `}\n        </SyntaxHighlighter>\n        <p>Або відразу в сигнатурі (підпису) функції, різниці немає.</p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          function doStuffWithBook({\n            title,\n            numberOfPages,\n            downloads,\n            rating,\n            isPublic,\n          }) {\n            console.log(title);\n            console.log(numberOfPages);\n            // і так далі\n          }  \n                `}\n        </SyntaxHighlighter>\n      </div>\n    </div>\n  );\n};\n\nexport default SpreadRest;\n","/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/Lessons/CallBack.jsx",["105"],[],"import React from \"react\";\nimport { Prism as SyntaxHighlighter } from \"react-syntax-highlighter\";\nimport { materialDark } from \"react-syntax-highlighter/dist/esm/styles/prism\";\n\nimport s from \"./Lessons.module.css\";\nimport sprite from \"../../img/icomoon/sprite.svg\";\nimport Scrollspy from \"react-scrollspy\";\nimport callBack01 from \"../../img/callBack01.jpeg\";\nimport declarative from \"../../img/declarative.jpeg\";\nconst CallBack = () => {\n  const codeStyle = materialDark;\n  return (\n    <div className={s.lessonsBox}>\n      <div className={s.breadNav}>\n        <Scrollspy\n          items={[\"branching\", \"section-2\", \"section-3\"]}\n          currentClassName=\"is-current\"\n        >\n          <div className={s.breadNavList}>\n            <li>\n              <a href=\"#callBack\">Колбек-функції</a>\n            </li>\n            <li>\n              <a href=\"#forEach\">Метод forEach</a>\n            </li>\n            <li>\n              <a href=\"#arroeFn\">Стрілочні функції</a>\n            </li>\n            <li>\n              <a href=\"#codeType\">Різновиди коду</a>\n            </li>\n          </div>\n        </Scrollspy>\n      </div>\n      <div className={s.article}>\n        <h1 id=\"callBack\">Колбек-функції</h1>\n        <p>\n          Функції не відрізняються від чисел, рядків або масивів - це просто\n          спеціальний тип даних (об'єкт вищого порядку), значення, яке можна\n          зберігати в змінній або передавати як аргумент на іншу функцію.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          function greet(name) {\n           return \\`Ласкаво просимо  $\\{name}.\\`;\n           }\n\n           // Викликаємо функцію greet та виводимо результати в консоль\n           console.log(greet(\"Манго\")); // Ласкаво просимо Манго.\n\n           // Виводимо функцію greet в консоль не викликаючи її\n           console.log(greet); // ƒ greet() { return \\`Ласкаво просимо $\\{name}.\\`; }\n                `}\n        </SyntaxHighlighter>\n        <p>\n          У першому лозі ми викликаємо функцію{\" \"}\n          <span className={s.Span}>greet</span> за допомогою круглих дужок і в\n          консоль виводиться результат виконання. У другому лозі передається{\" \"}\n          <strong>посилання на функцію</strong> , а не результат виклику\n          (відсутні круглі дужки), тому консоль виводиться її тіло. Це означає,\n          що функцію можна присвоїти змінну або передати як аргумент іншої\n          функції.\n        </p>\n        <p>\n          <strong>Функція зворотного виклику (callback, колбек)</strong> - це\n          функція, яка передається інший функції як аргумент і та, своєю чергою,\n          викликає передану функцію.\n        </p>\n        <p>\n          <strong> Функція вищого порядку (higher order function)</strong> -\n          функція, яка приймає як параметри інші функції або повертає функцію як\n          результат.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          // Колбек-функція\n            function greet(name) {\n            console.log(\\`Ласкаво просимо  $\\{name}.\\`);\n            }\n\n            // Функция высшего порядка\n            function registerGuest(name, callback) {\n            console.log(\\`Реєструємо гостя $\\{name}.\\`);\n            callback(name);\n            }\n\n            registerGuest(\"Манго\", greet);\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Ми передали посилання на функцію <span className={s.Span}>greet</span>{\" \"}\n          як аргумент, тому вона буде присвоєна в параметр{\" \"}\n          <span className={s.Span}>callback</span> і викликана всередині функції{\" \"}\n          <span className={s.Span}>registerGuest</span> через круглі дужки. Ім'я\n          параметра колбека може бути довільним, головне пам'ятати, що значенням\n          буде функція.\n        </p>\n        <h3>Інлайн колбеки</h3>\n        <p>\n          Якщо колбек-функція невелика і потрібна лише передачі аргументом, її\n          можна оголосити при виклику функції у яку передаємо колбек. Така\n          функція буде доступна лише як значення параметра та більше ніде у\n          коді.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          function registerGuest(name, callback) {\n            console.log(\\`Реєструємо гостя $\\{name}.\\`);\n            callback(name);\n            }\n\n            // Передаємо інлайн функцію greet як колбек\n            registerGuest(\"Манго\", function greet(name) {\n            console.log(\\`Ласкаво просимо $\\{name}.\\`);\n            });\n\n            // Передаємо інлайн функцію notify як колбек\n            registerGuest(\"Полі\", function notify(name) {\n            console.log(\\`Шановний(а) $\\{name}, ваш номер буде готовий через 30 хвилин.\\`);\n            });\n                `}\n        </SyntaxHighlighter>\n        <h3>Кілька колбеків</h3>\n        <p>\n          Функція може приймати довільну кількість колбеків. Наприклад, уявимо,\n          що ми пишемо логіку прийняття дзвінків для телефону. Програма повинна\n          увімкнути автовідповідач, якщо абонент недоступний, або з'єднати\n          дзвінок в іншому випадку. Доступність абонента імітуватимемо\n          генератором випадкового числа, щоб між різними викликами функції можна\n          було отримати різні результати.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          function processCall(recipient) {\n            //Імітуємо доступність абонента випадковим числом\n            const isRecipientAvailable = Math.random() > 0.5;\n\n            if (!isRecipientAvailable) {\n                console.log(\\`Абонент $\\{recipient} недоступний, залиште повідомлення.\\`);\n                // Логіка активації автовідповідача\n            } else {\n                console.log(\\`Зʼєднуємо з $\\{recipient}, очікуйте...\\`);\n             // Логіка прийнятя дзвінка\n            }\n            }\n\n            processCall(\"Манго\");\n                `}\n        </SyntaxHighlighter>\n        <p>\n          {\" \"}\n          Проблема такого підходу в тому, що функція{\" \"}\n          <span className={s.Span}>processCall</span> робить занадто багато і\n          прив'язує перевірку доступності абонента до двох наперед визначених\n          дій. Що якщо в майбутньому замість автовідповідача потрібно залишати\n          голограму? Ми могли б написати функцію так, щоб вона повертала якесь\n          значення і потім за результатом виконання виконувати перевірки і\n          виконувати потрібний код. Але перевірки не відносяться до зовнішнього\n          коду і засмічуватимуть його. Виконаємо рефакторинг функції так, щоб\n          вона приймала два колбеки\n          <span className={s.Span}>onAvailable</span> і{\" \"}\n          <span className={s.Span}>onNotAvailable</span>, і викликала їх за\n          умовою.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          function processCall(recipient, onAvailable, onNotAvailable) {\n           //Імітуємо доступність абонента випадковим числом\n           const isRecipientAvailable = Math.random() > 0.5;\n\n           if (!isRecipientAvailable) {\n               onNotAvailable(recipient);\n               return;\n           }\n\n           onAvailable(recipient);\n           }\n\n           function takeCall(name) {\n           console.log(\\`Зʼєднуємо з $\\{name}, очікуйте...\\`);\n           // Логіка прийнятя дзвінка\n           }\n\n           function activateAnsweringMachine(name) {\n            console.log(\\`Абонент $\\{name} недоступний, залиште повідомлення.\\`);\n           // Логіка активації автовідповідача\n           }\n\n           function leaveHoloMessage(name) {\n           console.log(\\`Абонент $\\{name} недоступний, записуємо голограму.\\`);\n           // Логіка запису голограми\n           }\n\n           processCall(\"Манго\", takeCall, activateAnsweringMachine);\n           processCall(\"Поли\", takeCall, leaveHoloMessage);\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Колбеки застосовуються для обробки дій користувача на сторінці, при\n          обробці запитів на сервер, виконання заздалегідь невідомих функцій\n          тощо. У цьому полягає їх суть - це функції призначені для відкладеного\n          виконання.\n        </p>\n        <h3>Абстрагування повторення</h3>\n        <p>\n          Абстракція – приховування деталей реалізації. Дозволяє думати про\n          завдання на вищому (абстрактному) рівні. Функції це добрий спосіб\n          побудови абстракцій.\n        </p>\n        Наприклад, скрипт виконує якусь дію певну кількість разів. Для цього\n        можна написати цикл <span className={s.Span}>for</span>.\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            for (let i = 0; i < 10; i += 1) {\n                console.log(i);\n            } \n                `}\n        </SyntaxHighlighter>\n        <p>\n          Чи можемо ми абстрагувати \"робити щось N раз\" як функцію? - так,\n          напишемо функцію, яка викликає{\" \"}\n          <span className={s.Span}>console.log()</span> N разів.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          function repeatLog(n) {\n            for (let i = 0; i < n; i += 1) {\n             console.log(i);\n            }\n            }\n\n          repeatLog(5);\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Але що якщо ми хочемо зробити щось, крім логування чисел? Оскільки\n          «робити щось» можна як функцію, а функції - це значення, ми можемо\n          передати дію як аргумент.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n         function printValue(value) {\n           console.log(value);\n         }\n\n         function prettyPrint(value) {\n            console.log(\"Logging value: \", value);\n         }\n\n         function repeat(n, action) {\n           for (let i = 0; i < n; i += 1) {\n            action(i);\n         }\n         }\n\n         // Передаємо printValue як callback-функцію\n         repeat(3, printValue);\n         // 0\n         // 1\n         // 2\n\n         // Передаємо prettyPrint як callback-функцию\n         repeat(3, prettyPrint);\n         // Logging value: 0\n         // Logging value: 1\n         // Logging value: 2\n                `}\n        </SyntaxHighlighter>\n        <h1 id=\"forEach\">Метод forEach</h1>\n        <p>\n          Перебираючий метод масиву, який використовується як заміна циклів{\" \"}\n          <span className={s.Span}>for</span> і{\" \"}\n          <span className={s.Span}>for...of</span> при роботі з колекцією даних.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          масив.forEach(function callback(element, index, array) {\n            // Тіло колбек-функції\n          });\n                `}\n        </SyntaxHighlighter>\n        <ul>\n          <li>Поелементно перебирає масив.</li>\n          <li>Викликає колббек-функцію для кожного елемента масиву.</li>\n          <li>Нічого не вертає.</li>\n        </ul>\n        <p>\n          Аргументи коллбек-функції це значення поточного елемента{\" \"}\n          <span className={s.Span}>element</span>, його індекс{\" \"}\n          <span className={s.Span}>index</span> і вихідний масив\n          <span className={s.Span}>array</span>. Оголошувати можна тільки ті\n          параметри, які потрібні, найчастіше це елемент, головне не забувати\n          про їх порядок.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const numbers = [5, 10, 15, 20, 25];\n\n           // Классический for\n           for (let i = 0; i < numbers.length; i += 1) {\n           console.log(\\`Индекс $\\{i}, значение $\\{numbers[i]}\\`);\n           }\n\n           // Перебирающий forEach\n           numbers.forEach(function (number, index) {\n           console.log(\\`Индекс $\\{index}, значение $\\{number}\\`);\n           });\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Єдиним випадком, коли варто використовувати цикли{\" \"}\n          <span className={s.Span}>for</span> або\n          <span className={s.Span}>for...of</span> для перебору масиву це\n          завдання з перериванням виконання циклу. Перервати виконання методу{\" \"}\n          <span className={s.Span}>forEach</span> не можна, він завжди перебирає\n          масив остаточно.\n        </p>\n        <h1 id=\"arroeFn\">Стрілочні функції</h1>\n        <p>\n          Стрілецькі функції мають скорочений, більш лаконічний синтаксис, що\n          зменшує обсяг коду, особливо коли функція маленька або якщо вона\n          використовується як колббек.\n        </p>\n        <p>\n          Усі стрілки створюються як{\" \"}\n          <span className={s.Span}>функціональне вираз</span>, і якщо функція не\n          анонімна, вона повинна бути присвоєна змінної.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          // Звичайне оголошення функції\n            function classicAdd(a, b, c) {\n            return a + b + c;\n            }\n\n            // Теж саме, як стрілочна функція\n            const arrowAdd = (a, b, c) => {\n            return a + b + c;\n            };\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Ключове слово <span className={s.Span}>function</span> не\n          використовується, натомість відразу йде оголошення параметрів, за\n          якими слідує символ <span className={s.Span}>=></span> і тіло функції.\n        </p>\n        <p>\n          Якщо параметрів кілька, то вони перераховуються через кому в круглих\n          дужках, між знаками <span className={s.Span}>=</span> і стрілкою{\" \"}\n          <span className={s.Span}>=></span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const add = (a, b, c) => {\n            return a + b + c;\n          };\n                `}\n        </SyntaxHighlighter>\n        <p>Якщо параметр один, його оголошення може бути без круглих дужок.</p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const add = a => {\n            return a + 5;\n          };\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Якщо параметрів немає, обов'язково повинні бути порожні круглі дужки.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const greet = () => {\n            console.log(\"Привіт!\");\n          };  \n                `}\n        </SyntaxHighlighter>\n        <h3>Неявне повернення</h3>\n        <p>\n          У стрілочній функції після символу <span className={s.Span}>=></span>{\" \"}\n          йде її тіло. Тут може бути два варіанти: з фігурними дужками та без\n          них.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n           const add = (a, b, c) => {\n             console.log(a, b, c);\n             return a + b + c;\n           }; \n                `}\n        </SyntaxHighlighter>\n        <p>\n          Якщо фігурні дужки є і функція повинна повертати якесь значення,\n          необхідно явно поставити <span className={s.Span}>return</span>. Це\n          називається явне повернення (explicit return). Такий синтаксис\n          використовується в тому випадку, якщо в тілі функції потрібно виконати\n          ще якісь інструкції, крім повернення значення.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const add = (a, b, c) => a + b + c;\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Якщо фігурних дужок немає, то повертається результат виразу, що стоїть\n          після <span className={s.Span}>=></span>. Це називається неявне\n          повернення (implicit return). У прикладі повернеться результат\n          вираження додавання параметрів <span className={s.Span}>a</span>,{\" \"}\n          <span className={s.Span}>b</span> і <span className={s.Span}>c</span>.\n        </p>\n        <p>\n          Синтаксис неявного повернення сильно скорочує «шум» оголошення функції\n          з тілом і виразом, що повертається, але підходить тільки у випадку\n          коли в тілі функції не потрібно виконувати ніяких додаткових\n          інструкцій крім повернення значення.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          // До\n          function classicAdd(a, b, c) {\n          return a + b + c;\n          }\n\n          // Після\n          const arrowAdd = (a, b, c) => a + b + c;\n                `}\n        </SyntaxHighlighter>\n        <h3>\n          Псевдомасив <span className={s.Span}>arguments</span>\n        </h3>\n        <p>\n          У стрілочних функцій немає локальної змінної{\" \"}\n          <span className={s.Span}>arguments</span>, що містить усі аргументи.\n          Якщо потрібно зібрати всі аргументи в масив, використовується операція{\" \"}\n          <span className={s.Span}>rest</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const add = (...args) => {\n          console.log(args);\n          };\n\n          add(1, 2, 3); // [1, 2, 3]\n                `}\n        </SyntaxHighlighter>\n        <h3>Стрілкові функції як колбеки</h3>\n        <p>\n          Анонімні стрілочні функції відмінно підходять як колббеки для методів\n          масиву, що перебирають, через більш короткий синтаксис оголошення,\n          особливо якщо не потрібно тіло функції.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const numbers = [5, 10, 15, 20, 25];\n\n           // Оголошення функції\n           numbers.forEach(function (number, index) {\n           console.log(\\`Індекс $\\{index}, значення $\\{number}\\`);\n           });\n\n           // Анонімна стрілочна функція\n           numbers.forEach((number, index) => {\n           console.log(\\`Індекс $\\{index}, значення $\\{number}\\`);\n           });\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Стрілочну коллбек-функцію також можна оголошувати окремо та передавати\n          на неї посилання. Це варто робити, якщо одна функція використовується\n          в кількох місцях програми або якщо вона громіздка.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const numbers = [5, 10, 15, 20, 25];\n\n          const logMessage = (number, index) => {\n              console.log(\\`Індекс $\\{index}, знечення $\\{number}\\`);\n          };\n\n          numbers.forEach(logMessage);\n                `}\n        </SyntaxHighlighter>\n        <h1 id=\"codeType\">Різновиди коду</h1>\n        <p>\n          Описує процес обчислення у вигляді заданої послідовності інструкцій,\n          що змінюють стан програми. Опис того, як виконується щось.\n        </p>\n        <p>\n          <strong>Імперативний стиль програмування</strong> – це такий, що дає\n          машині набір детальних інструкцій для виконання завдання. Наприклад,\n          цикл <span className={s.Span}>for</span>, який надає точні вказівки\n          для ітерації за індексами масиву.\n        </p>\n        <p>\n          Можна провести аналогію з рецептом приготування страви. Рецепт – це\n          набір покрокових інструкцій для отримання бажаного результату.\n        </p>\n        <div style={{ display: \"flex\", justifyContent: \"center\" }}>\n          <img src={callBack01} alt=\"\" />\n        </div>\n        <h3>Декларативне програмування</h3>\n        <p>\n          Описує те, що хочемо отримати в результаті, а не як це зробити.\n          Порядок виконання та спосіб досягнення не важливий.\n        </p>\n        <p>\n          Коли ми пишемо HTML-код, то декларативно, за допомогою тегів та\n          атрибутів, описуємо те, що хочемо отримати в результаті. Браузер читає\n          цей код і сам виконує всі необхідні операції зі створення\n          HTML-елементів та розміщення їх на сторінці.\n        </p>\n        <p>\n          Можна провести аналогію з меню ресторану. Це декларативний набір\n          можливих для замовлення страв, деталі приготування та подачі яких\n          приховані.\n        </p>\n        <div style={{ display: \"flex\", justifyContent: \"center\" }}>\n          <img src={declarative} alt=\"\" />\n        </div>\n        <p>\n          Декларативний опис завдання більш наочно та легше формулюється. Ми\n          говоримо, що хочемо зробити, викликавши метод чи функцію. Її\n          реалізація, швидше за все, використовує імперативний код, але він\n          прихований усередині і не ускладнює розуміння основного коду.\n        </p>\n        <h3>Імперативний vs декларативний</h3>\n        <p>\n          Розглянемо різницю підходів з прикладу базової операції фільтрації\n          колекції. Напишемо код перебору та фільтрації масиву чисел за якимось\n          критерієм.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          // Імперативний підхід\n            const numbers = [1, 2, 3, 4, 5];\n            const filteredNumbers = [];\n\n            for (let i = 0; i < numbers.length; i += 1) {\n               if (numbers[i] > 3) {\n                  filteredNumbers.push(numbers[i]);\n               }\n            }\n\n            console.log(filteredNumbers); // [4, 5]\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Метод <span className={s.Span}>filter()</span> приховує в собі логіку\n          перебору колекції і викликає callback-функцію, яку ми передаємо йому\n          для кожного елемента, повертаючи масив елементів, що підійшли під\n          критерій.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          // Декларативний підхід\n            const numbers = [1, 2, 3, 4, 5];\n            const filteredNumbers = numbers.filter(value => value > 3);\n            console.log(filteredNumbers); // [4, 5] \n                `}\n        </SyntaxHighlighter>\n      </div>\n    </div>\n  );\n};\n\nexport default CallBack;\n","/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/Lessons/ArrMethod.jsx",["106","107","108"],[],"import React from \"react\";\nimport { Prism as SyntaxHighlighter } from \"react-syntax-highlighter\";\nimport { materialDark } from \"react-syntax-highlighter/dist/esm/styles/prism\";\n\nimport s from \"./Lessons.module.css\";\nimport sprite from \"../../img/icomoon/sprite.svg\";\nimport Scrollspy from \"react-scrollspy\";\nimport callBack01 from \"../../img/callBack01.jpeg\";\nimport declarative from \"../../img/declarative.jpeg\";\nconst ArrayMethod = () => {\n  const codeStyle = materialDark;\n  return (\n    <div className={s.lessonsBox}>\n      <div className={s.breadNav}>\n        <Scrollspy\n          items={[\"branching\", \"section-2\", \"section-3\"]}\n          currentClassName=\"is-current\"\n        >\n          <div className={s.breadNavList}>\n            <li>\n              <a href=\"#cleanFn\">Чисті функції</a>\n            </li>\n            <li>\n              <a href=\"#arrMethod\">Перебираючі методи масиву</a>\n            </li>\n            <li>\n              <a href=\"#map\">Метод map()</a>\n            </li>\n            <li>\n              <a href=\"#flatMap\">Метод flatmap()</a>\n            </li>\n            <li>\n              <a href=\"#filter\">Метод filter()</a>\n            </li>\n            <li>\n              <a href=\"#find\">Метод find()</a>\n            </li>\n            <li>\n              <a href=\"#findIndex\">Метод findIndex()</a>\n            </li>\n            <li>\n              <a href=\"#every\">Метод every() та some()</a>\n            </li>\n            <li>\n              <a href=\"#reduce\">Метод reduce()</a>\n            </li>\n            <li>\n              <a href=\"#codeType\">Метод sort()</a>\n            </li>\n            <li>\n              <a href=\"#codeType\">Ланцюжки методів</a>\n            </li>\n          </div>\n        </Scrollspy>\n      </div>\n      <div className={s.article}>\n        <h1 id=\"cleanFn\">Чисті функції</h1>\n        <p>\n          <strong>Функція з побічними ефектами</strong> - це функція яка у\n          процесі виконання може змінювати або використовувати глобальні змінні,\n          змінювати значення аргументів типу посилання, виконувати операції\n          введення-виведення тощо.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n            const dirtyMultiply = (array, value) => {\n              for (let i = 0; i < array.length; i += 1) {\n                array[i] = array[i] * value;\n              }\n            };\n\n            const numbers = [1, 2, 3, 4, 5];\n            dirtyMultiply(numbers, 2);\n            // Відбулась мутація вихідних даних - масиву numbers\n            console.log(numbers); // [2, 4, 6, 8, 10]    `}\n        </SyntaxHighlighter>\n        <p>\n          Функція <span className={s.Span}>dirtyMultiply(array, value)</span>{\" \"}\n          множить кожен елемент масиву <span className={s.Span}>array</span> на\n          число <span className={s.Span}>value</span>. Вона змінює (мутує)\n          вихідний масив за посиланням.\n        </p>\n        <p>\n          <strong>Чиста функція (pure function)</strong> - це функція, результат\n          якої залежить тільки від значень переданих аргументів. При однакових\n          аргументах вона завжди повертає той самий результат і не має побічних\n          ефектів, тобто не змінює значення аргументів.\n        </p>\n        <p>\n          Напишемо реалізацію чистої функції множення елементів масиву, що\n          повертає новий масив, не змінюючи вихідний.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const pureMultiply = (array, value) => {\n            const newArray = [];\n\n            array.forEach(element => {\n              newArray.push(element * value);\n            });\n\n            return newArray;\n          };\n\n          const numbers = [1, 2, 3, 4, 5];\n          const doubledNumbers = pureMultiply(numbers, 2);\n\n          // Не відбулось мутації вихідних даних\n          console.log(numbers); // [1, 2, 3, 4, 5]\n          // Функція повернула новий масив з зміненими даними\n          console.log(doubledNumbers); // [2, 4, 6, 8, 10]\n                `}\n        </SyntaxHighlighter>\n        <h1 id=\"arrMethod\">Перебираюч методи масиву</h1>\n        <p>\n          У JavaScript є методи масивів, що прийшли з функціональних мов.\n          Більшість із них це чисті функції. Вони створюють новий масив,\n          заповнюють його, застосовуючи значення кожного елемента зазначену\n          коллбек-функцію, після чого повертають цей новий масив.\n        </p>\n        <p>\n          Всі методи масивів, що перебирають, мають подібний синтаксис. Вихідний\n          масив <span className={s.Span}>array</span>, виклик методу{\" \"}\n          <span className={s.Span}>method</span> та callback-функція{\" \"}\n          <span className={s.Span}>callbac</span> kяк аргумент методу.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          array.method(callback[currentValue, index, array])\n                `}\n        </SyntaxHighlighter>\n        <p>\n          У більшості методів аргументами callback-функції є значення елемента\n          <span className={s.Span}>currentValue</span> (перший параметр),\n          позиція елемента\n          <span className={s.Span}>index</span>(другий параметр) і сам вихідний\n          масив <span className={s.Span}>array</span>(третій параметр).\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          array.method((item, idx, arr) => {\n            // логіка яка буде застосовуватись на кожній ітерації \n          });\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Усі параметри, крім значення елемента{\" \"}\n          <span className={s.Span}>item</span>, необов'язкові. Назви параметрів\n          можуть бути будь-які, але є неофіційні угоди.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          array.method(item => {\n            // логіка яка буде застосовуватись на кожній ітерації\n          });\n                `}\n        </SyntaxHighlighter>\n        <h1 id=\"map\">Метод map()</h1>\n        <p>\n          Метод <span className={s.Span}>map(callback)</span> використовується\n          для трансформації масиву. Він викликає коллбек-функцію для кожного\n          елемента вихідного масиву, а результат її роботи записує новий масив,\n          який і буде результатом виконання методу.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          масив.map((element, index, array) => {\n            // Тіло колбек-функції\n          });\n                `}\n        </SyntaxHighlighter>\n        <ul>\n          <li>Поелементно перебирає оригінальний масив.</li>\n          <li>Чи не змінює оригінальний масив.</li>\n          <li>Результат роботи коллбек-функції записується в новий масив.</li>\n          <li>Повертає новий масив такої ж довжини.</li>\n        </ul>\n        <p>\n          Його можна використовувати для того, щоб змінити кожен елемент масиву.\n          Оригінальний масив використовується як зразок, на основі якого можна\n          створити іншу колекцію.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const planets = [\"Земля\", \"Марс\", \"Венера\", \"Юпітер\"];\n\n          const planetsInUpperCase = planets.map(planet => planet.toUpperCase());\n          console.log(planetsInUpperCase); // ['ЗЕМЛЯ', 'МАРС', 'ВЕНЕРА', 'ЮПІТЕР']\n\n          const planetsInLowerCase = planets.map(planet => planet.toLowerCase());\n          console.log(planetsInLowerCase); // ['земля', 'марс', 'венера', 'юпітер']\n\n          // Оригінальний масив не змінився\n          console.log(planets); // ['Земля', 'Марс', 'Венера', 'Юпітер']\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Використання анонімних стрілочних функцій з неявним поверненням сильно\n          скорочує шум шуму оголошення коллбек-функції, роблячи код чистіше і\n          простіше для сприйняття.\n        </p>\n        <h3>Масив обʼєктів</h3>\n        <p>\n          Ми вже знаємо, що повсякденне завдання це маніпуляція масивом\n          об'єктів. Наприклад, отримати масив значень якості з усіх об'єктів. Є\n          масив студентів, а потрібно отримати окремий масив їхніх імен.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const students = [\n            { name: \"Манго\", score: 83 },\n            { name: \"Полі\", score: 59 },\n            { name: \"Аякс\", score: 37 },\n            { name: \"Ківі\", score: 94 },\n            { name: \"Хʼюстон\", score: 64 },\n          ];\n\n          const names = students.map(student => student.name);\n          console.log(names); // ['Манго', 'Полі', 'Аякс', 'Ківі', 'Хʼюстон']\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Використовуючи метод <span className={s.Span}>map()</span> можна\n          перебрати масив об'єктів, і колббек-функции повернути значення якості\n          кожного їх.\n        </p>\n        <h1 id=\"flatMap\">Метод flatMap()</h1>\n        <p>\n          Метод <span className={s.Span}>flatMap(callback)</span> аналогічний\n          методу <span className={s.Span}>map()</span>, але застосовується у\n          випадках коли результат це багатовимірний масив, який необхідно\n          «розгладити».\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          массив.flatMap((element, index, array) => {\n            // Тіло колбек-функції\n          });\n                `}\n        </SyntaxHighlighter>\n        <p>\n          У масиві <span className={s.Span}>students</span> зберігається список\n          студентів зі списком предметів, які відвідує студент у властивості{\" \"}\n          <span className={s.Span}>courses</span>. Декілька студентів можуть\n          відвідувати один і той же предмет. Необхідно скласти список усіх\n          предметів, які відвідує ця група студентів, що поки що навіть\n          повторюються.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const students = [\n            { name: \"Манго\", courses: [\"математика\", \"фізика\"] },\n            { name: \"Полі\", courses: [\"інформатика\", \"математика\"] },\n            { name: \"Ківі\", courses: [\"фізика\", \"біологія\"] },\n          ];\n\n          students.map(student => student.courses);\n          // [['математика', 'фізика'], ['інформатика', 'математика'], ['фізика', 'біологія']]\n\n          students.flatMap(student => student.courses);\n          // ['математика', 'фізика', 'інформатика', 'математика', 'фізика', 'біологія'];\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Він викликає коллбек-функцію кожного елемента вихідного масиву, а\n          результат її роботи записує у новий масив. Відмінність{\" \"}\n          <span className={s.Span}>map()</span> у тому, що новий масив\n          «розгладжується» на глибину рівну одиниці (одна вкладеність). Цей\n          розгладжений масив і є результатом роботи{\" \"}\n          <span className={s.Span}>flatMap()</span>.\n        </p>\n        <h1 id=\"filter\">Метод filter()</h1>\n        <p>\n          Метод <span className={s.Span}>filter(callback)</span>{\" \"}\n          використовується для єдиної операції – фільтрації масиву, тобто коли\n          необхідно вибрати більше одного елемента з колекції за якимось\n          критерієм.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          массив.filter((element, index, array) => {\n            // Тіло колбек-функції\n          });\n                `}\n        </SyntaxHighlighter>\n        <ul>\n          <li>Не змінює оригінальний масив.</li>\n          <li>Поелементно перебирає оригінальний масив.</li>\n          <li>Повертає новий масив.</li>\n          <li>\n            Додає в масив, що повертається, елементи, які задовольняють умові\n            коллбек-функції.\n          </li>\n          <li>\n            Якщо колббек повернув <span className={s.Span}>true</span> елемент\n            додається в масив, що повертається.\n          </li>\n          <li>\n            Якщо колббек повернув <span className={s.Span}>false</span> елемент\n            не додається в масив, що повертається.\n          </li>\n          <li>\n            Якщо жоден елемент не задовольнив умову, повертає порожній масив.\n          </li>\n        </ul>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const values = [51, -3, 27, 21, -68, 42, -37];\n\n          const positiveValues = values.filter(value => value >= 0);\n          console.log(positiveValues); // [51, 27, 21, 42]\n\n          const negativeValues = values.filter(value => value < 0);\n          console.log(negativeValues); // [-3, -68, -37]\n\n          const bigValues = values.filter(value => value > 1000);\n          console.log(bigValues); // []\n\n          // Оригінальний масив не змінюється\n          console.log(values); // [51, -3, 27, 21, -68, 42, -37]\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Тобто метод <span className={s.Span}>filter</span> викликає\n          колббек-функцію для кожного елемента вихідного масиву і якщо результат\n          її виконання <span className={s.Span}>true</span> поточний елемент\n          додає в новий масив.\n        </p>\n        <h3>Фільтрування унікальних елементів</h3>\n        <p>\n          Використовуючи метод, <span className={s.Span}>filter()</span> можна\n          виконати фільтрацію масиву так, що в ньому залишаться тільки унікальні\n          елементи. Цей прийом працює лише з масивом примітивних значень – не\n          об'єктів.\n        </p>\n        <p>\n          Повернемося до групи студентів та масиву всіх відвідуваних предметів,\n          які ми отримали методом <span className={s.Span}>flatMap()</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const students = [\n            { name: \"Манго\", courses: [\"математика\", \"фізика\"] },\n            { name: \"Поли\", courses: [\"інформатика\", \"математика\"] },\n            { name: \"Киви\", courses: [\"фізика\", \"біологія\"] },\n          ];\n\n          const allCourses = students.flatMap(student => student.courses);\n          // ['математика', 'фізика', 'інформатика', 'математика', 'фізика', 'біологія'];\n                `}\n        </SyntaxHighlighter>\n        <p>\n          У змінній <span className={s.Span}>allCourses</span> зберігається\n          масив всіх відвідуваних предметів, які можуть повторюватися. Завдання\n          полягає в тому, щоб зробити новий масив, у якому будуть лише унікальні\n          предмети, тобто без повторень.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const uniqueCourses = allCourses.filter(\n            (course, index, array) => array.indexOf(course) === index\n          );\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Використовуючи <span className={s.Span}>array.indexOf(course)</span>{\" \"}\n          виконуємо пошук першого збігу поточного елемента{\" \"}\n          <span className={s.Span}>course</span> та отримуємо його індекс у\n          оригінальному масиві всіх курсів. У параметрі\n          <span className={s.Span}>index</span> зберігається індекс поточного\n          елемента <span className={s.Span}>course</span> при переборі масиву\n          методом <span className={s.Span}>filter</span>.\n        </p>\n        <p>\n          Якщо результат <span className={s.Span}>indexOf()</span> і значення{\" \"}\n          <span className={s.Span}>index</span> рівні - це унікальний елемент,\n          тому що це перший раз, коли таке значення зустрічається в масиві і на\n          поточній ітерації фільтр обробляє саме його.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          # Масив всіх курсів\n          ['математика', 'фізика', 'інформатика', 'математика', 'фізика', 'біологія'];\n                `}\n        </SyntaxHighlighter>\n        <p>Для елемента 'математика'під індексом 0:</p>\n        <ul>\n          <li>span indexOf()поверне 0, тому що шукає перший збіг.</li>\n          <li>\n            Значення параметра <span className={s.Span}>index</span> буде 0.\n          </li>\n          <li>Вони рівні, отже, це унікальний елемент.</li>\n        </ul>\n        <p>\n          Для елемента <span className={s.Span}>'математика'</span> під індексом\n          3:\n        </p>\n        <ul>\n          <li>\n            <span className={s.Span}>indexOf()</span> поверне 0, тому що шукає\n            перший збіг.\n          </li>\n          <li>\n            Значення параметра <span className={s.Span}>index</span> буде 3.\n          </li>\n          <li>Вони не рівні, отже, це повторюваний - не унікальний елемент.</li>\n        </ul>\n        <h3>Масив обʼєктів</h3>\n        <p>\n          Працюючи з масивом об'єктів виконується фільтрація за значенням\n          якогось властивості. В результаті виходить новий масив відфільтрованих\n          об'єктів.\n        </p>\n        <p>\n          Наприклад, є масив студентів із балами за тест. Необхідно\n          відфільтрувати кращих (бал вище 80), найгірших (бал нижче 50) та\n          середніх студентів (бал від 50 до 80).\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const LOW_SCORE = 50;\n          const HIGH_SCORE = 80;\n          const students = [\n            { name: \"Манго\", score: 83 },\n            { name: \"Полі\", score: 59 },\n            { name: \"Аякс\", score: 37 },\n            { name: \"Ківі\", score: 94 },\n            { name: \"Хʼюстон\", score: 64 },\n          ];\n\n          const best = students.filter(student => student.score >= HIGH_SCORE);\n          console.log(best); // Масив обʼєктів з іменами Манго и Ківі\n\n          const worst = students.filter(student => student.score < LOW_SCORE);\n          console.log(worst); // Масив з одним обʼєктом Аякс\n\n          // В колбек-функції зручно  деструктурувати властивості обʼєкта\n          const average = students.filter(\n            ({ score }) => score >= LOW_SCORE && score < HIGH_SCORE\n          );\n          console.log(average); // Масив обʼєктів з іменами Полі та Хʼюстон\n                `}\n        </SyntaxHighlighter>\n        <h1 id=\"find\">Метод find()</h1>\n        <p>\n          Якщо метод <span className={s.Span}>filter(callback)</span>{\" \"}\n          використовується для пошуку всіх елементів, що задовольняють умові, то\n          метод\n          <span className={s.Span}>find(callback)</span> дозволяє знайти і\n          повернути перший відповідний елемент, після чого перебір масиву\n          припиняється. Тобто він шукає до першого збігу.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          массив.find((element, index, array) => {\n            // Тіло колбек-функції\n          });\n                `}\n        </SyntaxHighlighter>\n        <ul>\n          <li>Не змінює оригінальний масив.</li>\n          <li>Поелементно перебирає оригінальний масив.</li>\n          <li>\n            Повертає перший елемент, що задовольняє умові, тобто коли коллбек\n            повертає <span className={s.Span}>true</span>.\n          </li>\n          <li>\n            Якщо жоден елемент не підійшов, тобто всім елементів коллбек\n            повернув <span className={s.Span}>false</span>, метод повертає{\" \"}\n            <span className={s.Span}>undefined</span>.\n          </li>\n        </ul>\n        <p>\n          Метод <span className={s.Span}>find()</span> використовується для\n          одного завдання - пошуку елемента за унікальним значенням якості.\n          Наприклад, пошук користувача поштою, автомобіля за серійним номером,\n          книги за назвою тощо.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const colorPickerOptions = [\n            { label: \"red\", color: \"#F44336\" },\n            { label: \"green\", color: \"#4CAF50\" },\n            { label: \"blue\", color: \"#2196F3\" },\n            { label: \"pink\", color: \"#E91E63\" },\n            { label: \"indigo\", color: \"#3F51B5\" },\n          ];\n\n          colorPickerOptions.find(option => option.label === \"blue\"); // { label: 'blue', color: '#2196F3' }\n          colorPickerOptions.find(option => option.label === \"pink\"); // { label: 'pink', color: '#E91E63' }\n          colorPickerOptions.find(option => option.label === \"white\"); // undefined\n                `}\n        </SyntaxHighlighter>\n        <h1 id=\"findIndex\">Метод findIndex()</h1>\n        <p>\n          Метод <span className={s.Span}>findIndex(callback)</span> це сучасна\n          заміна методу\n          <span className={s.Span}>indexOf()</span>. Дозволяє виконувати пошук\n          за складнішими умовами, ніж просто рівність. Використовується як у\n          масиві примітивів, і у масиві об'єктів.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          масив.findIndex((element, index, array) => {\n            // Тіло колбек-функції\n          });\n                `}\n        </SyntaxHighlighter>\n        <ul>\n          <li>Не змінює оригінальний масив.</li>\n          <li>Поелементно перебирає оригінальний масив.</li>\n          <li>\n            Повертає індекс першого елемента, що задовольняє умові, тобто коли\n            коллбек повертає <span className={s.Span}>true</span>.\n          </li>\n          <li>\n            Якщо жоден елемент не підійшов, тобто всім елементів коллбек\n            повернув <span className={s.Span}>false</span>, метод повертає{\" \"}\n            <span className={s.Span}>-1</span>.\n          </li>\n        </ul>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const colorPickerOptions = [\n            { label: \"red\", color: \"#F44336\" },\n            { label: \"green\", color: \"#4CAF50\" },\n            { label: \"blue\", color: \"#2196F3\" },\n            { label: \"pink\", color: \"#E91E63\" },\n            { label: \"indigo\", color: \"#3F51B5\" },\n          ];\n\n          colorPickerOptions.findIndex(option => option.label === \"blue\"); // 2\n          colorPickerOptions.findIndex(option => option.label === \"pink\"); // 3\n          colorPickerOptions.findIndex(option => option.label === \"white\"); // -1\n                `}\n        </SyntaxHighlighter>\n        <h1 id=\"every\">Методи every() та some()</h1>\n        <h3>\n          Метод <span className={s.Span}>every()</span>\n        </h3>\n        <p>\n          Перевіряє чи проходять всі елементи масиву тест надається\n          коллбек-функцією. Повертає <span className={s.Span}>true</span> або{\" \"}\n          <span className={s.Span}>false</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          масив.every((element, index, array) => {\n            // Тіло колбек-функції\n          });\n                `}\n        </SyntaxHighlighter>\n        <ul>\n          <li>Не змінює оригінальний масив.</li>\n          <li>Поелементно перебирає оригінальний масив.</li>\n          <li>\n            Повертає <span className={s.Span}>true</span>, якщо всі елементи\n            масиву задовольняють умові.\n          </li>\n          <li>\n            Повертає <span className={s.Span}>false</span> якщо хоча б один\n            елемент масив не задовольняє умову.\n          </li>\n          <li>\n            Перебір масиву припиняється, якщо коллбек повертає{\" \"}\n            <span className={s.Span}>false</span>.\n          </li>\n        </ul>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          // Всі елементи більше або дорівнюють нулю? - так\n          [1, 2, 3, 4, 5].every(value => value >= 0); // true\n\n          // Всі елементи більше або дорівнюють нулю? - ні\n          [1, 2, 3, -10, 4, 5].every(value => value >= 0); // false\n                `}\n        </SyntaxHighlighter>\n        <h3>\n          Метод <span className={s.Span}>some()</span>\n        </h3>\n        <p>\n          Перевіряє чи проходить хоча б один елемент масиву тест, що надається\n          коллбек-функцією. Повертає <span className={s.Span}>true</span> або{\" \"}\n          <span className={s.Span}>false</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          масив.some((element, index, array) => {\n            // Тіло колбек-функції\n          });\n                `}\n        </SyntaxHighlighter>\n        <ul>\n          <li>Не змінює оригінальний масив.</li>\n          <li>Поелементно перебирає оригінальний масив.</li>\n          <li>\n            Повертає <span className={s.Span}>true</span> якщо хоча б один\n            елемент масиву задовольняє умову.\n          </li>\n          <li>\n            Повертає <span className={s.Span}>false</span> якщо жоден елемент\n            масиву не задовольняє умові.\n          </li>\n          <li>\n            Перебір масиву припиняється, якщо коллбек повертає{\" \"}\n            <span className={s.Span}>true</span>.\n          </li>\n        </ul>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          // Якщо хоча б один елемент бцльше або рівний нулю? - так\n          [1, 2, 3, 4, 5].some(value => value >= 0); // true\n\n          // кщо хоча б один елемент бцльше або рівний нулю? - так\n          [-7, -20, 3, -10, -14].some(value => value >= 0); // true\n\n          // Є хочаб один елемент менший нуля?  - ні\n          [1, 2, 3, 4, 5].some(value => value < 0); // false\n\n          // Є хочаб один елемент менший нуля? - так\n          [1, 2, 3, -10, 4, 5].some(value => value < 0); // true\n                `}\n        </SyntaxHighlighter>\n        <h3>Масив обʼєктів</h3>\n        <p>\n          При роботі з масивом об'єктів перевіряється значення якоїсь їхньої\n          властивості. Наприклад, є масив об'єктів фруктів, необхідно дізнатися\n          чи всі фрукти є в наявності і чи є в наявності хоч якісь фрукти більше\n          0 штук.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const fruits = [\n            { name: \"apples\", amount: 100 },\n            { name: \"bananas\", amount: 0 },\n            { name: \"grapes\", amount: 50 },\n          ];\n\n          // every поверне true лише якщо всіх фруктів буде більше ніж 0 штук\n          const allAvailable = fruits.every(fruit => fruit.amount > 0); // false\n\n          // some поверне true якщо хочаб одного фрукта буде більще ніж 0 штук\n          const anyAvailable = fruits.some(fruits => fruits.amount > 0); // true\n                `}\n        </SyntaxHighlighter>\n        <h1 id=\"reduce\">\n          Метод <span className={s.Span}>reduce()</span>\n        </h1>\n        <p>\n          Метод <span className={s.Span}>reduce(callback, initialValue)</span>{\" \"}\n          використовується для послідовної обробки кожного елемента масиву зі\n          збереженням проміжного результату як акумулятор. Трохи складніше за\n          інших у засвоєнні, але результат вартий того.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          масив.reduce((previousValue, element, index, array) => {\n            // Тіло колбек-функції\n          }, initialValue);\n                `}\n        </SyntaxHighlighter>\n        <ul>\n          <li>Не змінює оригінальний масив.</li>\n          <li>Поелементно перебирає оригінальний масив.</li>\n          <li>Повертає будь-що.</li>\n          <li>Робить будь-що.</li>\n        </ul>\n        <p>\n          Найлегше уявити його роботу на прикладі підрахунку суми елементів\n          масиву.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const total = [2, 7, 3, 14, 6].reduce((previousValue, number) => {\n            return previousValue + number;\n          }, 0);\n\n          console.log(total); // 32\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Перший параметр колббек-функції (\n          <span className={s.Span}>previousValue</span>) це акумулятор, тобто\n          проміжний результат. Значення, яке поверне колббек-функція на поточну\n          ітерацію, буде значенням цього параметра на наступному.\n        </p>\n        <p>\n          Другим аргументом <span className={s.Span}>reduce()</span> можна\n          передати необов'язкове початкове значення акумулятора - параметр{\" \"}\n          <span className={s.Span}>initialValue</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          # Спочатку метод reduce() створює внутрішню змінну-акумулятор та\n          # призначає їй значення параметра initialValue або першого елемента\n          # масива, що перебирається якщо initialValue не вказаний.\n          previousValue = 0\n\n          # Далі колбек-функція викликається для кожного елемента масиву. Поточне значення\n          # параметра previousValue це те, що повернула колбек-функція на минулій ітерації.\n          Ітерація 1 -> previousValue = 0 -> number = 2 -> return 0 + 2 -> return 2\n          Ітерація 2 -> previousValue = 2 -> number = 7 -> return 2 + 7 -> return 9\n          Ітерація 3 -> previousValue = 9 -> number = 3 -> return 9 + 3 -> return 12\n          Ітерація 4 -> previousValue = 12 -> number = 14 -> return 12 + 14 -> return 26\n          Ітерація 5 -> previousValue = 26 -> number = 6 -> return 26 + 6 -> return 32\n\n          # Після того, як весь масив перебрано, метод reduce() повертає значення акумулятора.\n          Результат - 32\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Тобто метод <span className={s.Span}>reduce()</span> використовується,\n          коли необхідно взяти «багато» і привести до «одного». У повсякденних\n          завданнях застосування зводиться до роботи з числами.\n        </p>\n        <h3>Масив обʼєктів</h3>\n        <p>\n          Працюючи з масивом об'єктів виконується редукування за значенням\n          якогось властивості. Наприклад, є масив студентів із балами за тест.\n          Потрібно отримати середній бал.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const students = [\n            { name: \"Манго\", score: 83 },\n            { name: \"Полі\", score: 59 },\n            { name: \"Аякс\", score: 37 },\n            { name: \"Ківі\", score: 94 },\n            { name: \"Хʼюстон\", score: 64 },\n          ];\n\n          // Назва акумулятора може бути довільною, це просто параметр функції\n          const totalScore = students.reduce((total, student) => {\n            return total + student.score;\n          }, 0);\n\n          const averageScore = totalScore / students.length;\n                `}\n        </SyntaxHighlighter>\n        <h3>\n          Просунутий <span className={s.Span}>reduce</span>\n        </h3>\n        <p>\n          Припустимо, у нас є наступне завдання: з масиву постів твіттера\n          окремого користувача необхідно порахувати суму всіх лайків. Можна\n          перебрати циклом <span className={s.Span}>for</span> або{\" \"}\n          <span className={s.Span}>forEach</span>, кожне з цих рішень вимагатиме\n          додаткового коду. А можна використовувати reduce.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const tweets = [\n            { id: \"000\", likes: 5, tags: [\"js\", \"nodejs\"] },\n            { id: \"001\", likes: 2, tags: [\"html\", \"css\"] },\n            { id: \"002\", likes: 17, tags: [\"html\", \"js\", \"nodejs\"] },\n            { id: \"003\", likes: 8, tags: [\"css\", \"react\"] },\n            { id: \"004\", likes: 0, tags: [\"js\", \"nodejs\", \"react\"] },\n          ];\n\n          // Пройдемось по всім елементам колекціїта додамо значення властивості likes\n          // до акумулятора, початкове значення якого вкажемо 0.\n          const likes = tweets.reduce((totalLikes, tweet) => totalLikes + tweet.likes, 0);\n\n          console.log(likes); // 32\n\n          // Мабуть підрахунок лайків не одиночна операція, тому напищемо функцію \n          // для підрахунку лайків з колекції\n          const countLikes = tweets => {\n            return tweets.reduce((totalLikes, tweet) => totalLikes + tweet.likes, 0);\n          };\n\n          console.log(countLikes(tweets)); // 32\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Помітили властивість <span className={s.Span}>tags</span> кожного\n          посту? Продовжуючи тему\n          <span className={s.Span}>reduce</span>, ми зберемо до масиву всі теги,\n          які зустрічаються в постах.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const tweets = [\n            { id: \"000\", likes: 5, tags: [\"js\", \"nodejs\"] },\n            { id: \"001\", likes: 2, tags: [\"html\", \"css\"] },\n            { id: \"002\", likes: 17, tags: [\"html\", \"js\", \"nodejs\"] },\n            { id: \"003\", likes: 8, tags: [\"css\", \"react\"] },\n            { id: \"004\", likes: 0, tags: [\"js\", \"nodejs\", \"react\"] },\n          ];\n\n          // Пройдемось по всім елементам колекції та додамо значення властивості tags\n          // до акумулятора, початкове занчення якого вкажемо пустим масивом [].\n          // На кожній ітерації пушимо всі елементи tweet.tags та повертаємо його.\n          const tags = tweets.reduce((allTags, tweet) => {\n            allTags.push(...tweet.tags);\n\n            return allTags;\n          }, []);\n\n          console.log(tags);\n\n          // Мабуть збір тегів не одиночна операція, тому напишемо функцію\n          // для отримання тегів з колекції\n          const getTags = tweets =>\n            tweets.reduce((allTags, tweet) => {\n              allTags.push(...tweet.tags);\n\n              return allTags;\n            }, []);\n\n          console.log(getTags(tweets));\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Після того, як ми зібрали всі теги з постів, добре було б порахувати\n          кількість унікальних тегів у масиві. І знову{\" \"}\n          <span className={s.Span}>reduce</span> тут.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const tweets = [\n            { id: \"000\", likes: 5, tags: [\"js\", \"nodejs\"] },\n            { id: \"001\", likes: 2, tags: [\"html\", \"css\"] },\n            { id: \"002\", likes: 17, tags: [\"html\", \"js\", \"nodejs\"] },\n            { id: \"003\", likes: 8, tags: [\"css\", \"react\"] },\n            { id: \"004\", likes: 0, tags: [\"js\", \"nodejs\", \"react\"] },\n          ];\n\n          const getTags = tweets =>\n            tweets.reduce((allTags, tweet) => {\n              allTags.push(...tweet.tags);\n\n              return allTags;\n            }, []);\n\n          const tags = getTags(tweets);\n\n          // Виносимо callback-функцію окремо, а в reducе передамо посилання на неї.\n          // Це стандартна практика, якщо callback-функція доволі велика.\n\n          // Якщо в обʼєкті-акумуляторі acc немає власної властивості з ключем tag,\n          // то створюємо його та запиуємо йому значення 0.\n          // В іншому випадку збільшуємо значення на 1.\n            const getTagStats = (acc, tag) => {\n            if (!acc.hasOwnProperty(tag)) {\n              acc[tag] = 0;\n            }\n\n            acc[tag] += 1;\n\n            return acc;\n          };\n\n          // Початкове значення акумулятора це пустий обʼєкт {}\n          const countTags = tags => tags.reduce(getTagStats, {});\n\n          const tagCount = countTags(tags);\n          console.log(tagCount);\n                `}\n        </SyntaxHighlighter>\n        <h1>\n          Метод <span className={s.Span}>sort()</span>\n        </h1>\n        <p>\n          Метод <span className={s.Span}>sort()</span> сортує елементи масиву,\n          але на відміну від інших методів, що перебирають, він сортує вихідний\n          масив.\n        </p>\n        <ul>\n          <li>Сортує та змінює вихідний масив.</li>\n          <li>\n            Повертає змінений масив, тобто посилання відсортований вихідний.\n          </li>\n          <li>По дефолту сортує за зростанням.</li>\n          <li>\n            Сортування відбувається шляхом приведення значень до рядка та\n            порівняння порядкових номерів у таблиці Unicode.\n          </li>\n        </ul>\n        <p>Такий масив чисел буде відсортований за зростанням.</p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const scores = [61, 19, 74, 35, 92, 56];\n          scores.sort();\n          console.log(scores); // [19, 35, 56, 61, 74, 92]\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Але, оскільки за умовчанням значення наводяться до рядка, стандартне\n          сортування чисел працює незвично. Тому в наступній вправі ми\n          розглянемо, як задавати свій порядок сортування.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const scores = [27, 2, 41, 4, 7, 3, 75];\n          scores.sort();\n          console.log(scores); // [2, 27, 3, 4, 41, 7, 75]\n                `}\n        </SyntaxHighlighter>\n        <p>Масив рядків сортується за абеткою.</p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const students = [\"Віка\", \"Андрій\", \"Олег\", \"Юля\", \"Борис\", \"Катя\"];\n          students.sort();\n          console.log(students); // [ 'Андрій', 'Борис', 'Віка', 'Катя', 'Олег', 'Юля' ]\n                `}\n        </SyntaxHighlighter>\n        <p>При цьому порядковий номер великих літер менший ніж у великих.</p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const letters = [\"b\", \"B\", \"a\", \"A\", \"c\", \"C\"];\n          letters.sort();\n          console.log(letters); // ['A', 'B', 'C', 'a', 'b', 'c']\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Через те, що сортується вихідний масив, порушується принцип чистоти\n          функцій і не можна зручно зробити кілька похідних колекцій на основі\n          вихідної. Наприклад, зробити колекцію відсортовану за зростанням, а\n          іншу за спаданням. Тому перед сортуванням роблять повну копію\n          вихідного масиву та сортують вже її.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const scores = [61, 19, 74, 35, 92, 56];\n          const ascendingScores = [...scores].sort();\n\n          console.log(scores); // [61, 19, 74, 35, 92, 56]\n          console.log(ascendingScores); // [19, 35, 56, 61, 74, 92]\n                `}\n        </SyntaxHighlighter>\n        <h3>Свій порядок сортування чисел</h3>\n        <p>\n          Для вказівки свого порядку сортування методу\n          <span className={s.Span}>sort(compareFunction)</span> потрібно\n          передати колббек-функцію з двома параметрами. Це функція порівняння\n          (compare function), порядок сортування залежить від його результату.\n          Метод <span className={s.Span}>sort()</span> викликатиме її для\n          довільних двох елементів.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          масив.sort((a, b) => {\n            // Тіло коілбек-функції\n          });\n                `}\n        </SyntaxHighlighter>\n        <ul>\n          <li>\n            <span className={s.Span}>a</span> - Перший елемент для порівняння.\n          </li>\n          <li>\n            <span className={s.Span}>b</span> - Другий елемент для порівняння.\n          </li>\n        </ul>\n        <p>\n          Якщо виклик <span className={s.Span}>compareFunction(a, b)</span>{\" \"}\n          повертає будь-яке негативне значення, тобто{\" \"}\n          <span className={s.Span}>a</span> менше{\" \"}\n          <span className={s.Span}>b</span>, сортування поставить{\" \"}\n          <span className={s.Span}>a</span> перед{\" \"}\n          <span className={s.Span}>b</span>. Це сортування за зростанням.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const scores = [61, 19, 74, 35, 92, 56];\n          const ascendingScores = [...scores].sort((a, b) => a - b);\n          console.log(ascendingScores); // [19, 35, 56, 61, 74, 92]\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Якщо виклик <span className={s.Span}>compareFunction(a, b)</span>{\" \"}\n          повертає будь-яке позитивне значення більше за нуль, тобто{\" \"}\n          <span className={s.Span}>b</span> більше{\" \"}\n          <span className={s.Span}>a</span>, сортування поставить{\" \"}\n          <span className={s.Span}>b</span> перед{\" \"}\n          <span className={s.Span}>a</span>. Це сортування за спаданням.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const scores = [61, 19, 74, 35, 92, 56];\n          const descendingScores = [...scores].sort((a, b) => b - a);\n          console.log(descendingScores); // [92, 74, 61, 56, 35, 19]\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Якщо виклик <span className={s.Span}>compareFunction(a, b)</span>{\" \"}\n          поверне <span className={s.Span}>0</span>, сортування залишить{\" \"}\n          <span className={s.Span}>a</span> незмінними{\" \"}\n          <span className={s.Span}>b</span> по відношенню один до одного, але\n          відсортує їх по відношенню до всіх інших елементів. Але взагалі не\n          важливо, що повертати, якщо їхній взаємний порядок не має значення.\n        </p>\n        <h3>Свій порядок сортування рядків</h3>\n        <p>\n          Для сортування рядків в алфавітному порядку, за зростанням або\n          зменшенням, використовується метод рядків{\" \"}\n          <span className={s.Span}>localeCompare()</span>.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          firstString.localeCompare(secondString)\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Він викликається на рядку, який потрібно порівняти ({\" \"}\n          <span className={s.Span}>firstString</span> ) з тим, що передано йому\n          як аргумент (<span className={s.Span}>secondString</span>).\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          \"a\".localeCompare(\"b\"); // -1\n          \"b\".localeCompare(\"a\"); // 1\n          \"a\".localeCompare(\"a\"); // 0\n          \"b\".localeCompare(\"b\"); // 0\n                `}\n        </SyntaxHighlighter>\n        <ul>\n          <li>\n            Повертає негативне значення якщо{\" \"}\n            <span className={s.Span}>firstString</span> має бути перед{\" \"}\n            <span className={s.Span}>secondString</span>.\n          </li>\n          <li>\n            Повертає позитивне значення більше нуля якщо{\" \"}\n            <span className={s.Span}>firstString</span> має бути після{\" \"}\n            <span className={s.Span}>secondString</span>.\n          </li>\n          <li>Якщо рядки однакові, повертається нуль.</li>\n        </ul>\n        <p>\n          Це зручно використовувати при сортуванні рядків, тому що метод\n          <span className={s.Span}>sort()</span> очікує такі ж значення від\n          колббек-функції.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const students = [\"Віка\", \"Андрій\", \"Олег\", \"Юля\", \"Борис\", \"Катя\"];\n\n          const inAlphabetOrder = [...students].sort((a, b) => a.localeCompare(b));\n          console.log(inAlphabetOrder); // ['Андрій', 'Борис', 'Віка', 'Катя', 'Олег', 'Юля']\n\n          const inReversedOrder = [...students].sort((a, b) => b.localeCompare(a));\n          console.log(inReversedOrder); // ['Юля', 'Олег', 'Катя', 'Віка', 'Борис', 'Андрій']\n                `}\n        </SyntaxHighlighter>\n        <h3>Сортування обʼєктів</h3>\n        <p>\n          При роботі з масивом об'єктів сортування виконується за числовим або\n          рядковим значенням якоїсь властивості. Наприклад, є група студентів із\n          балами за тест. Необхідно відсортувати масив об'єктів за зростанням та\n          зменшенням кількості балів, і на ім'я студента.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const students = [\n            { name: \"Манго\", score: 83 },\n            { name: \"Полі\", score: 59 },\n            { name: \"Аякс\", score: 37 },\n            { name: \"Ківі\", score: 94 },\n          ];\n\n          const inAscendingScoreOrder = students.sort(\n            (firstStudent, secondStudent) => firstStudent.score - secondStudent.score\n          );\n\n          const inDescendingScoreOrder = students.sort(\n            (firstStudent, secondStudent) => secondStudent.score - firstStudent.score\n          );\n\n          const inAlphabeticalOrder = students.sort((firstStudent, secondStudent) =>\n            firstStudent.name.localeCompare(secondStudent.name)\n          );\n                `}\n        </SyntaxHighlighter>\n        <h1>Ланцюжки методів</h1>\n        <p>\n          Є масив об'єктів з іменами, балами та предметами кожного студента.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const students = [\n            { name: \"Манго\", score: 83, courses: [\"математика\", \"фізика\"] },\n            { name: \"Полі\", score: 59, courses: [\"інформатика\", \"математика\"] },\n            { name: \"Аякс\", score: 37, courses: [\"фізика\", \"біологія\"] },\n            { name: \"Ківі\", score: 94, courses: [\"література\", \"інформатика\"] },\n          ];\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Необхідно одержати масив їх імен відсортований за зростанням балів за\n          тест. Для цього ми відсортуємо копію масиву методом{\" \"}\n          <span className={s.Span}>sort()</span>, після чого методом{\" \"}\n          <span className={s.Span}>map()</span> складемо масив значень\n          властивості <span className={s.Span}>name</span> сортованого масиву.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const sortedByAscendingScore = [...students].sort((a, b) => a.score - b.score);\n          const names = sortedByAscendingScore.map(student => student.name);\n\n          console.log(names); // ['Аякс', 'Полі', 'Манго', 'Ківі']\n                `}\n        </SyntaxHighlighter>\n        <p>\n          Проблема в тому, що у нас з'являються проміжні змінні після кожної\n          операції, крім фінальної. Змінна{\" \"}\n          <span className={s.Span}>sortedByAscendingScore</span> зайва та\n          необхідна лише для зберігання проміжного результату.\n        </p>\n        <p>\n          Позбутися таких «мертвих» змінних можна групуючи виклики методів у\n          ланцюжка. Кожен наступний метод виконуватиметься у результаті роботи\n          попереднього.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const names = [...students]\n            .sort((a, b) => a.score - b.score)\n            .map(student => student.name);\n\n          console.log(names); // ['Аякс', 'Полі', 'Манго', 'Ківі']\n                `}\n        </SyntaxHighlighter>\n        <ul>\n          <ol>Робимо копію вихідного масиву перед сортуванням.</ol>\n          <ol>\n            На копії викликаємо метод <span className={s.Span}>sort()</span>.\n          </ol>\n          <ol>\n            До результату роботи методу <span className={s.Span}>sort()</span>{\" \"}\n            застосовуємо метод\n            <span className={s.Span}>map()</span>.\n          </ol>\n          <ol>\n            Змінної <span className={s.Span}>names</span> присвоюється результат\n            роботи методу\n            <span className={s.Span}>map()</span>.\n          </ol>\n        </ul>\n        <p>\n          Отримаємо сортований за алфавітом масив унікальних відвідуваних\n          предметів.\n        </p>\n        <SyntaxHighlighter language=\"javascript\" style={codeStyle}>\n          {`\n          const uniqueSortedCourses = students\n            .flatMap(student => student.courses)\n            .filter((course, index, array) => array.indexOf(course) === index)\n            .sort((a, b) => a.localeCompare(b));\n\n          console.log(uniqueSortedCourses); // ['біологія', 'інформатика', 'література', 'математика', 'фізика']\n                `}\n        </SyntaxHighlighter>\n        <ul>\n          <ol>\n            На вихідному масиві викликаємо{\" \"}\n            <span className={s.Span}>flatMap()</span> та робимо розгладжений\n            масив усіх курсів.\n          </ol>\n          <ol>\n            До результату методу <span className={s.Span}>flatMap()</span>{\" \"}\n            застосовуємо метод\n            <span className={s.Span}>filter()</span> фільтрації унікальних\n            елементів.\n          </ol>\n          <ol>\n            У результаті методу <span className={s.Span}>filter()</span>{\" \"}\n            викликаємо <span className={s.Span}>sort()</span>.\n          </ol>\n          <ol>\n            Змінної <span className={s.Span}>uniqueSortedCourses</span>{\" \"}\n            присвоюється результат роботи методу{\" \"}\n            <span className={s.Span}>sort()</span>.\n          </ol>\n        </ul>\n        <p>\n          Ланцюжок методів може бути довільної довжини, але зазвичай трохи\n          більше 2-3 операцій. По-перше, методи, що перебирають,\n          використовуються для порівняно простих операцій над колекцією.\n          По-друге, виклик кожного наступного методу, це додатковий перебір\n          масиву, що за достатньої кількості, може зашкодити продуктивності.\n        </p>\n      </div>\n    </div>\n  );\n};\n\nexport default ArrayMethod;\n","/Users/macbook/Documents/Java Script/JS_Lessons/src/Components/Lessons/This.jsx",["109","110"],[],{"ruleId":"111","severity":1,"message":"112","line":5,"column":8,"nodeType":"113","messageId":"114","endLine":5,"endColumn":16},{"ruleId":"111","severity":1,"message":"115","line":3,"column":17,"nodeType":"113","messageId":"114","endLine":3,"endColumn":26},{"ruleId":"111","severity":1,"message":"116","line":8,"column":3,"nodeType":"113","messageId":"114","endLine":8,"endColumn":10},{"ruleId":"111","severity":1,"message":"117","line":9,"column":3,"nodeType":"113","messageId":"114","endLine":9,"endColumn":7},{"ruleId":"111","severity":1,"message":"118","line":10,"column":3,"nodeType":"113","messageId":"114","endLine":10,"endColumn":9},{"ruleId":"111","severity":1,"message":"119","line":11,"column":3,"nodeType":"113","messageId":"114","endLine":11,"endColumn":13},{"ruleId":"111","severity":1,"message":"120","line":1,"column":8,"nodeType":"113","messageId":"114","endLine":1,"endColumn":16},{"ruleId":"111","severity":1,"message":"121","line":2,"column":17,"nodeType":"113","messageId":"114","endLine":2,"endColumn":25},{"ruleId":"111","severity":1,"message":"122","line":2,"column":27,"nodeType":"113","messageId":"114","endLine":2,"endColumn":36},{"ruleId":"111","severity":1,"message":"123","line":8,"column":8,"nodeType":"113","messageId":"114","endLine":8,"endColumn":22},{"ruleId":"111","severity":1,"message":"124","line":9,"column":8,"nodeType":"113","messageId":"114","endLine":9,"endColumn":22},{"ruleId":"111","severity":1,"message":"125","line":10,"column":8,"nodeType":"113","messageId":"114","endLine":10,"endColumn":14},{"ruleId":"111","severity":1,"message":"126","line":11,"column":8,"nodeType":"113","messageId":"114","endLine":11,"endColumn":13},{"ruleId":"111","severity":1,"message":"127","line":12,"column":8,"nodeType":"113","messageId":"114","endLine":12,"endColumn":24},{"ruleId":"128","severity":1,"message":"129","line":6,"column":13,"nodeType":"130","endLine":6,"endColumn":145},{"ruleId":"131","severity":1,"message":"132","line":259,"column":11,"nodeType":"130","messageId":"133","endLine":262,"endColumn":12,"fix":"134"},{"ruleId":"131","severity":1,"message":"132","line":265,"column":11,"nodeType":"130","messageId":"133","endLine":268,"endColumn":12,"fix":"135"},{"ruleId":"131","severity":1,"message":"132","line":534,"column":11,"nodeType":"130","messageId":"133","endLine":534,"endColumn":81,"fix":"136"},{"ruleId":"131","severity":1,"message":"132","line":537,"column":11,"nodeType":"130","messageId":"133","endLine":540,"endColumn":12,"fix":"137"},{"ruleId":"111","severity":1,"message":"138","line":6,"column":8,"nodeType":"113","messageId":"114","endLine":6,"endColumn":14},{"ruleId":"111","severity":1,"message":"138","line":6,"column":8,"nodeType":"113","messageId":"114","endLine":6,"endColumn":14},{"ruleId":"111","severity":1,"message":"138","line":6,"column":8,"nodeType":"113","messageId":"114","endLine":6,"endColumn":14},{"ruleId":"111","severity":1,"message":"139","line":8,"column":8,"nodeType":"113","messageId":"114","endLine":8,"endColumn":18},{"ruleId":"111","severity":1,"message":"140","line":9,"column":8,"nodeType":"113","messageId":"114","endLine":9,"endColumn":19},{"ruleId":"111","severity":1,"message":"139","line":8,"column":8,"nodeType":"113","messageId":"114","endLine":8,"endColumn":18},{"ruleId":"111","severity":1,"message":"140","line":9,"column":8,"nodeType":"113","messageId":"114","endLine":9,"endColumn":19},"no-unused-vars","'listData' is defined but never used.","Identifier","unusedVar","'Component' is defined but never used.","'NavLink' is defined but never used.","'Link' is defined but never used.","'Router' is defined but never used.","'HashRouter' is defined but never used.","'ReactDOM' is defined but never used.","'useState' is defined but never used.","'useEffect' is defined but never used.","'operatorTable1' is defined but never used.","'operatorTable2' is defined but never used.","'string' is defined but never used.","'code1' is defined but never used.","'booleanOperators' is defined but never used.","jsx-a11y/iframe-has-title","<iframe> elements must have a unique title property.","JSXOpeningElement","react/jsx-no-target-blank","Using target=\"_blank\" without rel=\"noreferrer\" (which implies rel=\"noopener\") is a security risk in older browsers: see https://mathiasbynens.github.io/rel-noopener/#recommendations","noTargetBlankWithoutNoreferrer",{"range":"141","text":"142"},{"range":"143","text":"142"},{"range":"144","text":"142"},{"range":"145","text":"142"},"'sprite' is defined but never used.","'callBack01' is defined but never used.","'declarative' is defined but never used.",[10059,10059]," rel=\"noreferrer\"",[10238,10238],[20969,20969],[21168,21168]]